<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Funciones MatemÃ¡ticas â€” IntroducciÃ³n</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.min.js"></script>
  <link rel="stylesheet" href="style.css">
  <style>
    /* â”€â”€ Canvas graphs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .graph-wrap {
      background: var(--s1);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin: 16px 0;
      overflow-x: auto;
    }
    .graph-title {
      font-family: 'JetBrains Mono', monospace;
      font-size: 9px;
      letter-spacing: .18em;
      color: var(--txt3);
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    canvas {
      display: block;
      width: 100%;
      max-width: 100%;
      border-radius: 6px;
    }
    /* â”€â”€ Tab system for graph sections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .tab-bar {
      display: flex;
      gap: 4px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }
    .tab-btn {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--txt3);
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      transition: all .2s;
    }
    .tab-btn:hover { color: var(--txt2); border-color: var(--border2); }
    .tab-btn.active { color: var(--accent); border-color: var(--accent); background: rgba(74,222,128,.07); }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    /* â”€â”€ Domain/range pill badges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .badge-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    .badge {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--txt2);
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 3px 12px;
      white-space: nowrap;
    }
    .badge strong { color: var(--txt); }
    /* â”€â”€ Interactive input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .input-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin: 12px 0;
    }
    .input-row label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--txt3);
      letter-spacing: .1em;
      text-transform: uppercase;
    }
    .input-row input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 140px;
      height: 2px;
      background: var(--border2);
      border-radius: 2px;
      outline: none;
    }
    .input-row input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px; height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
    }
    .input-row .val-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--accent);
      min-width: 36px;
    }
    /* â”€â”€ Feature row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      margin: 14px 0;
    }
    .feature-cell {
      background: var(--s1);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 14px;
    }
    .feature-cell .fc-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 9px;
      letter-spacing: .15em;
      color: var(--txt3);
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .feature-cell .fc-value {
      font-size: 14px;
      color: var(--txt);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CONSTRUCTOR DE FUNCIONES
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* Step counter header */
    .builder-step-header {
      display: flex;
      align-items: center;
      gap: 14px;
      margin-bottom: 18px;
    }
    .step-bubble {
      width: 28px; height: 28px;
      border-radius: 50%;
      background: var(--s2);
      border: 1px solid var(--border2);
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--txt2);
      display: flex; align-items: center; justify-content: center;
      flex-shrink: 0;
      transition: all .3s;
    }
    .step-bubble.done   { background: rgba(74,222,128,.15); border-color: var(--accent); color: var(--accent); }
    .step-bubble.active { background: var(--s2); border-color: var(--txt2); color: var(--txt); }
    .step-line {
      height: 1px; flex: 1; background: var(--border);
      transition: background .3s;
    }
    .step-line.done { background: var(--accent); opacity: .4; }

    /* Main input fields */
    .eq-input {
      width: 100%;
      background: var(--s2);
      border: 1px solid var(--border2);
      border-radius: 10px;
      padding: 12px 16px;
      color: var(--txt);
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      outline: none;
      transition: border-color .2s, box-shadow .2s;
      box-sizing: border-box;
    }
    .eq-input:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(74,222,128,.12); }
    .eq-input.error { border-color: #f87171; box-shadow: 0 0 0 2px rgba(248,113,113,.1); }
    .eq-input.ok    { border-color: var(--accent); }
    .eq-input::placeholder { color: var(--txt3); }

    /* Validation badge under input */
    .eq-status {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      letter-spacing: .1em;
      margin-top: 6px;
      min-height: 16px;
      transition: color .2s;
    }
    .eq-status.ok    { color: var(--accent); }
    .eq-status.error { color: #f87171; }
    .eq-status.warn  { color: #fbbf24; }
    .eq-status.hint  { color: var(--txt3); }

    /* Steps list */
    .steps-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 12px 0;
    }
    .step-row {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: start;
    }
    .step-input-wrap { position: relative; }
    .step-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 9px;
      letter-spacing: .15em;
      color: var(--txt3);
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .prop-select {
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--txt2);
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      padding: 4px 8px;
      outline: none;
      cursor: pointer;
      width: 100%;
      transition: border-color .2s;
    }
    .prop-select:focus, .prop-select:hover { border-color: var(--border2); color: var(--txt); }

    /* Step validity indicator */
    .step-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--border2);
      flex-shrink: 0;
      margin-top: 22px;
      transition: background .3s;
    }
    .step-dot.ok    { background: var(--accent); }
    .step-dot.error { background: #f87171; }
    .step-dot.warn  { background: #fbbf24; }

    .step-del-btn {
      background: none; border: none;
      color: var(--txt3); cursor: pointer;
      font-size: 16px; line-height: 1;
      padding: 0; margin-top: 18px;
      transition: color .2s;
    }
    .step-del-btn:hover { color: #f87171; }

    /* Add step / property buttons */
    .prop-pill-row {
      display: flex; gap: 6px; flex-wrap: wrap;
      margin: 10px 0;
    }
    .prop-pill {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      letter-spacing: .1em;
      text-transform: uppercase;
      color: var(--txt2);
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 5px 12px;
      cursor: pointer;
      transition: all .2s;
      white-space: nowrap;
    }
    .prop-pill:hover { color: var(--accent); border-color: var(--accent); background: rgba(74,222,128,.07); }

    /* Variable selector */
    .var-row {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      margin: 10px 0;
    }
    .var-btn {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--txt2);
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 16px;
      cursor: pointer;
      transition: all .2s;
    }
    .var-btn:hover, .var-btn.selected {
      color: var(--accent); border-color: var(--accent);
      background: rgba(74,222,128,.1);
    }

    /* Result block */
    .result-block {
      background: var(--s1);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 18px;
      margin-top: 14px;
    }
    .result-block .rl { font-family: 'JetBrains Mono', monospace; font-size: 9px; letter-spacing: .2em; text-transform: uppercase; color: var(--txt3); margin-bottom: 10px; }
    .result-fn-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 15px;
      color: var(--accent);
      margin: 8px 0 14px;
      word-break: break-all;
    }

    /* Action button */
    .builder-btn {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      letter-spacing: .15em;
      text-transform: uppercase;
      color: #0d0e12;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      padding: 10px 22px;
      cursor: pointer;
      transition: all .2s;
      font-weight: 600;
    }
    .builder-btn:hover { background: #86efac; }
    .builder-btn:disabled { background: var(--border2); color: var(--txt3); cursor: not-allowed; }
    .builder-btn.secondary {
      background: var(--s2); color: var(--txt2); border: 1px solid var(--border);
    }
    .builder-btn.secondary:hover { border-color: var(--border2); color: var(--txt); }

    /* Hint expandable */
    .hint-toggle {
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px; letter-spacing: .1em;
      color: var(--txt3); cursor: pointer;
      background: none; border: none; padding: 0;
      transition: color .2s;
    }
    .hint-toggle:hover { color: var(--txt2); }
    .hint-box {
      background: var(--s2);
      border: 1px solid var(--border);
      border-left: 2px solid #fbbf24;
      border-radius: 8px;
      padding: 12px 14px;
      margin: 8px 0;
      font-size: 13px;
      color: var(--txt2);
      display: none;
    }
    .hint-box.visible { display: block; }

    /* Error list */
    .error-list {
      background: rgba(248,113,113,.06);
      border: 1px solid rgba(248,113,113,.25);
      border-radius: 8px;
      padding: 12px 14px;
      margin: 10px 0;
      display: none;
    }
    .error-list.visible { display: block; }
    .error-list li {
      color: #fca5a5;
      font-size: 13px;
      font-family: 'JetBrains Mono', monospace;
      margin-bottom: 4px;
    }

    /* Equality chain display */
    .chain-display {
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--txt2);
      margin: 10px 0;
      overflow-x: auto;
      white-space: nowrap;
    }
    .chain-display .eq-link { color: var(--txt3); margin: 0 6px; }
    .chain-display .eq-current { color: var(--txt); font-weight: 600; }
    .chain-display .eq-ok { color: var(--accent); }
    .chain-display .eq-err { color: #f87171; }

    /* Graph control buttons */
    .graph-ctrl-btn {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      width: 26px; height: 26px;
      background: var(--s2);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--txt2);
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all .15s;
      padding: 0;
    }
    .graph-ctrl-btn:hover { border-color: var(--border2); color: var(--txt); background: var(--s1); }

    /* Section divider inside card */
    .builder-divider {
      border: none; border-top: 1px solid var(--border); margin: 20px 0;
    }
  </style>
</head>
<body>
<div class="page">
  <a href="index.html" class="back-link">â† Volver</a>
  <h1 class="page-title">Funciones <em>MatemÃ¡ticas</em></h1>
  <p class="page-sub">IntroducciÃ³n formal Â· dominio, imagen, operaciones y familias fundamentales</p>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1. DEFINICIÃ“N â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">DefiniciÃ³n formal</div>
    <p>Una <strong>funciÃ³n</strong> \( f: A \to B \) es una regla que asigna a cada elemento \( x \) del conjunto <em>dominio</em> \( A \) exactamente un elemento \( f(x) \) del conjunto <em>codominio</em> \( B \). La condiciÃ³n clave es la <em>unicidad</em>: un mismo \( x \) no puede producir dos salidas distintas.</p>
    <p class="math-block">$$ f: A \longrightarrow B \qquad x \longmapsto f(x) $$</p>
    <div class="info-box">
      <p><strong>TerminologÃ­a esencial:</strong> Â· <strong>Dominio</strong> \(\text{Dom}(f)=A\): valores de entrada permitidos Â· <strong>Codominio</strong> \(B\): conjunto donde viven las salidas Â· <strong>Imagen</strong> \(\text{Im}(f)=\{f(x)\mid x\in A\}\subseteq B\): salidas que realmente se alcanzan Â· <strong>Variable independiente</strong>: \(x\) Â· <strong>Variable dependiente</strong>: \(y=f(x)\).</p>
    </div>

    <h3>Criterio de la lÃ­nea vertical</h3>
    <p>Una curva en el plano representa una funciÃ³n si y sÃ³lo si toda lÃ­nea vertical la corta en <em>a lo sumo un punto</em>. Esto es la versiÃ³n geomÃ©trica de la unicidad.</p>

    <div class="graph-wrap">
      <div class="graph-title">Criterio de la lÃ­nea vertical â€” funciÃ³n vs. no-funciÃ³n</div>
      <canvas id="cvVertical" height="180"></canvas>
    </div>
  </div>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2. DOMINIO E IMAGEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">Dominio e imagen</div>
    <p>El dominio natural de una funciÃ³n real se obtiene excluyendo los valores que producen operaciones no definidas. Las restricciones mÃ¡s comunes:</p>

    <div class="table-wrap">
      <table>
        <thead><tr><th>ExpresiÃ³n</th><th>RestricciÃ³n</th><th>CondiciÃ³n</th></tr></thead>
        <tbody>
          <tr><td>\(\dfrac{1}{g(x)}\)</td><td>DivisiÃ³n por cero</td><td>\(g(x)\neq 0\)</td></tr>
          <tr><td>\(\sqrt{g(x)}\)</td><td>Radicando negativo</td><td>\(g(x)\geq 0\)</td></tr>
          <tr><td>\(\ln g(x)\)</td><td>Logaritmo de no-positivo</td><td>\(g(x)>0\)</td></tr>
          <tr><td>\(\arcsin g(x)\)</td><td>Argumento fuera de \([-1,1]\)</td><td>\(-1\leq g(x)\leq 1\)</td></tr>
        </tbody>
      </table>
    </div>

    <p><strong>Ejemplo:</strong> \( f(x)=\dfrac{\sqrt{x+3}}{x-1} \). Necesitamos \( x+3\geq 0 \) y \( x\neq 1 \):</p>
    <p class="math-block">$$ \text{Dom}(f) = [-3,\,1)\cup(1,+\infty) $$</p>

    <h3>Imagen de una funciÃ³n</h3>
    <p>Hallar la imagen requiere despejar \(x\) en funciÃ³n de \(y\) y determinar quÃ© valores de \(y\) producen soluciones vÃ¡lidas.</p>
    <p class="math-block">$$ f(x)=x^2 \;\Rightarrow\; y=x^2 \;\Rightarrow\; x=\pm\sqrt{y} \text{ existe sÃ³lo si } y\geq 0 \;\Rightarrow\; \text{Im}(f)=[0,+\infty) $$</p>
  </div>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3. TIPOS DE FUNCIONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">ClasificaciÃ³n por comportamiento</div>
    <p>SegÃºn la relaciÃ³n entre elementos del dominio y la imagen, una funciÃ³n puede ser:</p>

    <div class="feature-grid">
      <div class="feature-cell">
        <div class="fc-label">Inyectiva (1-a-1)</div>
        <div class="fc-value">Distintos \(x\) producen distintos \(f(x)\). Toda horizontal corta la grÃ¡fica a lo sumo una vez.</div>
      </div>
      <div class="feature-cell">
        <div class="fc-label">Sobreyectiva (sobre)</div>
        <div class="fc-value">Todo \(y\in B\) tiene al menos una preimagen. La imagen cubre todo el codominio.</div>
      </div>
      <div class="feature-cell">
        <div class="fc-label">Biyectiva</div>
        <div class="fc-value">Inyectiva y sobreyectiva a la vez. Existe funciÃ³n inversa \(f^{-1}\).</div>
      </div>
      <div class="feature-cell">
        <div class="fc-label">Par / Impar</div>
        <div class="fc-value"><strong>Par:</strong> \(f(-x)=f(x)\) â€” simetrÃ­a respecto al eje \(y\).<br><strong>Impar:</strong> \(f(-x)=-f(x)\) â€” simetrÃ­a respecto al origen.</div>
      </div>
    </div>

    <div class="graph-wrap">
      <div class="graph-title">Criterio de la lÃ­nea horizontal â€” inyectividad</div>
      <canvas id="cvInyectiva" height="180"></canvas>
    </div>
  </div>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4. OPERACIONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">Operaciones con funciones</div>

    <p>Dadas \(f\) y \(g\) con dominios \(D_f\) y \(D_g\), se definen las siguientes operaciones en \( D_f \cap D_g \) (salvo indicaciÃ³n):</p>

    <p class="math-block">$$ (f+g)(x)=f(x)+g(x) \qquad (f-g)(x)=f(x)-g(x) $$</p>
    <p class="math-block">$$ (f\cdot g)(x)=f(x)\,g(x) \qquad \left(\frac{f}{g}\right)\!(x)=\frac{f(x)}{g(x)},\quad g(x)\neq 0 $$</p>

    <h3>ComposiciÃ³n</h3>
    <p>La operaciÃ³n mÃ¡s importante en anÃ¡lisis. La funciÃ³n compuesta \((g\circ f)\) aplica primero \(f\), luego \(g\):</p>
    <p class="math-block">$$ (g\circ f)(x) = g\!\left(f(x)\right) \qquad \text{Dom}(g\circ f)=\{x\in D_f \mid f(x)\in D_g\} $$</p>
    <div class="info-box">
      <p>La composiciÃ³n <strong>no es conmutativa</strong> en general: \( g\circ f \neq f\circ g \). Ejemplo: con \( f(x)=x^2 \) y \( g(x)=x+1 \), se tiene \( (g\circ f)(x)=x^2+1 \) pero \( (f\circ g)(x)=(x+1)^2 \).</p>
    </div>

    <h3>FunciÃ³n inversa</h3>
    <p>Si \(f\) es biyectiva, existe \(f^{-1}: B \to A\) tal que \( f^{-1}(f(x))=x \). GeomÃ©tricamente, la grÃ¡fica de \(f^{-1}\) es el reflejo de la de \(f\) sobre la recta \(y=x\).</p>
    <p class="math-block">$$ f^{-1}(y)=x \;\Longleftrightarrow\; f(x)=y $$</p>
    <p class="math-block">$$ f(f^{-1}(y))=y \qquad f^{-1}(f(x))=x $$</p>

    <div class="graph-wrap">
      <div class="graph-title">FunciÃ³n e inversa â€” simetrÃ­a sobre y = x</div>
      <canvas id="cvInversa" height="220"></canvas>
    </div>
  </div>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 5. FAMILIAS FUNDAMENTALES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">Familias fundamentales</div>
    <p>Las siguientes familias son el vocabulario bÃ¡sico del anÃ¡lisis. Usa las pestaÃ±as para explorar cada una con su grÃ¡fica interactiva.</p>

    <div class="tab-bar" id="familyTabs">
      <button class="tab-btn active" data-tab="lineal">Lineal</button>
      <button class="tab-btn" data-tab="cuadratica">CuadrÃ¡tica</button>
      <button class="tab-btn" data-tab="potencia">Potencia</button>
      <button class="tab-btn" data-tab="exponencial">Exponencial</button>
      <button class="tab-btn" data-tab="logaritmo">LogarÃ­tmica</button>
      <button class="tab-btn" data-tab="trigono">TrigonomÃ©tricas</button>
    </div>

    <!-- LINEAL -->
    <div class="tab-panel active" id="tab-lineal">
      <p class="math-block">$$ f(x) = mx + b \qquad m,b\in\mathbb{R} $$</p>
      <div class="badge-row">
        <span class="badge"><strong>Dom:</strong> \(\mathbb{R}\)</span>
        <span class="badge"><strong>Im:</strong> \(\mathbb{R}\) si \(m\neq0\); \(\{b\}\) si \(m=0\)</span>
        <span class="badge"><strong>Pendiente:</strong> \(m\)</span>
        <span class="badge"><strong>Ordenada al origen:</strong> \(b\)</span>
      </div>
      <p>La recta es la funciÃ³n mÃ¡s sencilla. La pendiente \(m\) indica el cambio en \(y\) por unidad de \(x\). Cuando \(m=0\) la funciÃ³n es constante; la recta es horizontal.</p>
      <div class="input-row">
        <label>m =</label>
        <input type="range" id="slopeM" min="-4" max="4" step="0.25" value="1">
        <span class="val-display" id="slopeVal">1</span>
        <label>b =</label>
        <input type="range" id="slopeB" min="-4" max="4" step="0.25" value="0">
        <span class="val-display" id="slopeBVal">0</span>
      </div>
      <div class="graph-wrap">
        <div class="graph-title">f(x) = mx + b</div>
        <canvas id="cvLineal" height="200"></canvas>
      </div>
    </div>

    <!-- CUADRÃTICA -->
    <div class="tab-panel" id="tab-cuadratica">
      <p class="math-block">$$ f(x) = ax^2 + bx + c \qquad a\neq 0 $$</p>
      <div class="badge-row">
        <span class="badge"><strong>Dom:</strong> \(\mathbb{R}\)</span>
        <span class="badge"><strong>Im:</strong> \([v_y,+\infty)\) si \(a>0\); \((-\infty,v_y]\) si \(a<0\)</span>
        <span class="badge"><strong>VÃ©rtice:</strong> \(\left(-\tfrac{b}{2a},\,f\!\left(-\tfrac{b}{2a}\right)\right)\)</span>
      </div>
      <p>La parÃ¡bola abre hacia arriba si \(a>0\) (mÃ­nimo global) y hacia abajo si \(a<0\) (mÃ¡ximo global). El vÃ©rtice es el punto de simetrÃ­a del eje \(x=-b/(2a)\).</p>
      <p class="math-block">$$ f(x) = a\!\left(x - \frac{b}{2a}\right)^{\!2} - \frac{b^2-4ac}{4a} $$</p>
      <div class="input-row">
        <label>a =</label>
        <input type="range" id="quadA" min="-3" max="3" step="0.5" value="1">
        <span class="val-display" id="quadAVal">1</span>
        <label>b =</label>
        <input type="range" id="quadB" min="-4" max="4" step="0.5" value="0">
        <span class="val-display" id="quadBVal">0</span>
        <label>c =</label>
        <input type="range" id="quadC" min="-4" max="4" step="0.5" value="0">
        <span class="val-display" id="quadCVal">0</span>
      </div>
      <div class="graph-wrap">
        <div class="graph-title">f(x) = axÂ² + bx + c</div>
        <canvas id="cvCuad" height="200"></canvas>
      </div>
    </div>

    <!-- POTENCIA -->
    <div class="tab-panel" id="tab-potencia">
      <p class="math-block">$$ f(x) = x^n \qquad n\in\mathbb{R} $$</p>
      <div class="badge-row">
        <span class="badge"><strong>n par:</strong> simÃ©trica, \(\text{Im}=[0,+\infty)\)</span>
        <span class="badge"><strong>n impar:</strong> antisimÃ©trica, \(\text{Im}=\mathbb{R}\)</span>
        <span class="badge"><strong>n&lt;0:</strong> asÃ­ntota en \(x=0\)</span>
      </div>
      <p>Las funciones potencia con exponente entero positivo definen las familias <em>par</em> e <em>impar</em> que se alternan. Para exponentes fraccionarios como \(x^{1/2}=\sqrt{x}\) el dominio se restringe a \([0,+\infty)\).</p>
      <div class="input-row">
        <label>n =</label>
        <input type="range" id="powN" min="-3" max="5" step="1" value="2">
        <span class="val-display" id="powNVal">2</span>
      </div>
      <div class="graph-wrap">
        <div class="graph-title">f(x) = xâ¿</div>
        <canvas id="cvPot" height="200"></canvas>
      </div>
    </div>

    <!-- EXPONENCIAL -->
    <div class="tab-panel" id="tab-exponencial">
      <p class="math-block">$$ f(x) = a^x \qquad a>0,\; a\neq 1 $$</p>
      <div class="badge-row">
        <span class="badge"><strong>Dom:</strong> \(\mathbb{R}\)</span>
        <span class="badge"><strong>Im:</strong> \((0,+\infty)\)</span>
        <span class="badge"><strong>AsÃ­ntota:</strong> \(y=0\)</span>
        <span class="badge"><strong>f(0)=1</strong> siempre</span>
      </div>
      <p>Si \(a>1\) la funciÃ³n es creciente (crecimiento exponencial); si \(0&lt;a&lt;1\) es decreciente (decaimiento). La base natural \(e\approx2.718\) es fundamental en cÃ¡lculo porque \((e^x)'=e^x\).</p>
      <p class="math-block">$$ \frac{d}{dx}\,a^x = a^x\ln a \qquad \int a^x\,dx = \frac{a^x}{\ln a}+C $$</p>
      <div class="input-row">
        <label>a =</label>
        <input type="range" id="expA" min="0.2" max="4" step="0.1" value="2.718">
        <span class="val-display" id="expAVal">e</span>
      </div>
      <div class="graph-wrap">
        <div class="graph-title">f(x) = aË£</div>
        <canvas id="cvExp" height="200"></canvas>
      </div>
    </div>

    <!-- LOGARÃTMICA -->
    <div class="tab-panel" id="tab-logaritmo">
      <p class="math-block">$$ f(x) = \log_a x \qquad a>0,\; a\neq 1 $$</p>
      <div class="badge-row">
        <span class="badge"><strong>Dom:</strong> \((0,+\infty)\)</span>
        <span class="badge"><strong>Im:</strong> \(\mathbb{R}\)</span>
        <span class="badge"><strong>AsÃ­ntota:</strong> \(x=0\)</span>
        <span class="badge"><strong>f(1)=0</strong> siempre</span>
      </div>
      <p>El logaritmo es la inversa de la exponencial: \( \log_a(a^x)=x \). Los logaritmos convierten productos en sumas, y potencias en productos, lo que los hace indispensables en ingenierÃ­a, fÃ­sica y estadÃ­stica.</p>
      <p class="math-block">$$ \log_a(xy)=\log_a x+\log_a y \qquad \log_a(x^n)=n\log_a x $$</p>
      <p class="math-block">$$ \log_a x = \frac{\ln x}{\ln a} \qquad \frac{d}{dx}\ln x = \frac{1}{x} $$</p>
      <div class="input-row">
        <label>a =</label>
        <input type="range" id="logA" min="0.2" max="5" step="0.1" value="2.718">
        <span class="val-display" id="logAVal">e</span>
      </div>
      <div class="graph-wrap">
        <div class="graph-title">f(x) = logâ‚ x</div>
        <canvas id="cvLog" height="200"></canvas>
      </div>
    </div>

    <!-- TRIGONOMÃ‰TRICAS -->
    <div class="tab-panel" id="tab-trigono">
      <p class="math-block">$$ \sin x,\;\cos x,\;\tan x,\;\csc x,\;\sec x,\;\cot x $$</p>
      <div class="table-wrap">
        <table>
          <thead><tr><th>FunciÃ³n</th><th>Dominio</th><th>Imagen</th><th>PerÃ­odo</th></tr></thead>
          <tbody>
            <tr><td>\(\sin x\)</td><td>\(\mathbb{R}\)</td><td>\([-1,1]\)</td><td>\(2\pi\)</td></tr>
            <tr><td>\(\cos x\)</td><td>\(\mathbb{R}\)</td><td>\([-1,1]\)</td><td>\(2\pi\)</td></tr>
            <tr><td>\(\tan x\)</td><td>\(\mathbb{R}\setminus\{(2k+1)\pi/2\}\)</td><td>\(\mathbb{R}\)</td><td>\(\pi\)</td></tr>
          </tbody>
        </table>
      </div>
      <div class="input-row">
        <label>A =</label>
        <input type="range" id="trigA" min="0.5" max="3" step="0.25" value="1">
        <span class="val-display" id="trigAVal">1</span>
        <label>Ï‰ =</label>
        <input type="range" id="trigW" min="0.5" max="4" step="0.25" value="1">
        <span class="val-display" id="trigWVal">1</span>
      </div>
      <div class="graph-wrap">
        <div class="graph-title">AÂ·sen(Ï‰x), AÂ·cos(Ï‰x), tan(Ï‰x)</div>
        <canvas id="cvTrig" height="220"></canvas>
      </div>
      <div class="info-box">
        <p><strong>Identidades fundamentales:</strong> \(\sin^2 x+\cos^2 x=1\) Â· \(\tan x=\sin x/\cos x\) Â· \(\sin(2x)=2\sin x\cos x\) Â· \(\cos(2x)=\cos^2 x-\sin^2 x\).</p>
      </div>
    </div>
  </div>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 6. TRANSFORMACIONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">Transformaciones de la grÃ¡fica</div>
    <p>Partiendo de una funciÃ³n base \(f(x)\), se pueden obtener nuevas funciones mediante transformaciones geomÃ©tricas elementales:</p>

    <div class="table-wrap">
      <table>
        <thead><tr><th>TransformaciÃ³n</th><th>ExpresiÃ³n</th><th>Efecto sobre la grÃ¡fica</th></tr></thead>
        <tbody>
          <tr><td>TraslaciÃ³n vertical</td><td>\(f(x)+k\)</td><td>Desplaza \(k\) unidades hacia arriba (\(k>0\)) o abajo (\(k<0\))</td></tr>
          <tr><td>TraslaciÃ³n horizontal</td><td>\(f(x-h)\)</td><td>Desplaza \(h\) unidades a la derecha (\(h>0\)) o izquierda (\(h<0\))</td></tr>
          <tr><td>Escalado vertical</td><td>\(c\,f(x)\)</td><td>Estira (\(|c|>1\)) o comprime (\(|c|<1\)) verticalmente; refleja si \(c<0\)</td></tr>
          <tr><td>Escalado horizontal</td><td>\(f(cx)\)</td><td>Comprime (\(|c|>1\)) o estira (\(|c|<1\)) horizontalmente; refleja si \(c<0\)</td></tr>
          <tr><td>ReflexiÃ³n respecto a \(y\)</td><td>\(f(-x)\)</td><td>Imagen especular respecto al eje \(y\)</td></tr>
          <tr><td>ReflexiÃ³n respecto a \(x\)</td><td>\(-f(x)\)</td><td>Imagen especular respecto al eje \(x\)</td></tr>
        </tbody>
      </table>
    </div>

    <p>La forma <em>estÃ¡ndar</em> que concentra todas las transformaciones es:</p>
    <p class="math-block">$$ g(x) = c\,f\!\left(\frac{x-h}{b}\right)+k $$</p>
    <p>donde \(h\) traslada horizontalmente, \(k\) verticalmente, \(c\) escala verticalmente y \(b\) escala horizontalmente (perÃ­odo si \(f\) es periÃ³dica).</p>

    <div class="graph-wrap">
      <div class="graph-title">Transformaciones sobre f(x) = xÂ² â€” arrastra los parÃ¡metros</div>
      <div class="input-row">
        <label>h =</label>
        <input type="range" id="th" min="-3" max="3" step="0.5" value="0">
        <span class="val-display" id="thVal">0</span>
        <label>k =</label>
        <input type="range" id="tk" min="-3" max="3" step="0.5" value="0">
        <span class="val-display" id="tkVal">0</span>
        <label>c =</label>
        <input type="range" id="tc" min="-3" max="3" step="0.25" value="1">
        <span class="val-display" id="tcVal">1</span>
      </div>
      <canvas id="cvTransform" height="200"></canvas>
    </div>
  </div>

  <!-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 7. NOTACIÃ“N â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="card">
    <div class="card-label">NotaciÃ³n y sÃ­mbolos</div>
    <ul>
      <li>\( f, g, h \) â€” nombres de funciones; \( x \) â€” variable independiente; \( y = f(x) \) â€” variable dependiente</li>
      <li>\( \text{Dom}(f) \) â€” dominio de \(f\); \( \text{Im}(f) \) o \( f(A) \) â€” imagen de \(f\)</li>
      <li>\( f^{-1} \) â€” funciÃ³n inversa (no \(1/f\)); \( g\circ f \) â€” composiciÃ³n (\(g\) despuÃ©s de \(f\))</li>
      <li>\( \mathbb{R}, \mathbb{Q}, \mathbb{Z}, \mathbb{N} \) â€” reales, racionales, enteros, naturales</li>
      <li>\( [a,b], (a,b), [a,b), (a,b] \) â€” intervalos cerrado, abierto y semiabiertos</li>
      <li>\( f: \mathbb{R}\to\mathbb{R} \) â€” se lee "f de los reales en los reales"</li>
    </ul>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CONSTRUCTOR DE FUNCIONES
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="card" id="builder-card">
    <div class="card-label">Constructor de funciones</div>
    <p>Escribe una igualdad, aplÃ­cale transformaciones matemÃ¡ticas paso a paso y define la incÃ³gnita. La web verifica que la igualdad se mantenga en cada paso y genera la funciÃ³n final con su grÃ¡fica.</p>

    <!-- â”€â”€ Step progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
    <div class="builder-step-header">
      <div class="step-bubble active" id="bub1">1</div>
      <div class="step-line" id="sl12"></div>
      <div class="step-bubble" id="bub2">2</div>
      <div class="step-line" id="sl23"></div>
      <div class="step-bubble" id="bub3">3</div>
      <div class="step-line" id="sl34"></div>
      <div class="step-bubble" id="bub4">4</div>
    </div>
    <hr class="builder-divider">

    <!-- PASO 1 -->
    <div id="builderStep1">
      <div class="step-label">Paso 1 â€” Escribe la igualdad inicial</div>
      <p style="font-size:13px;margin-bottom:10px;">Ingresa una ecuaciÃ³n en la forma <code style="color:var(--txt);background:var(--s2);padding:2px 6px;border-radius:4px;">lado_izquierdo = lado_derecho</code>. Usa * para multiplicar, ^ para potencias. Ejemplos: <code style="color:var(--accent)">2*x + 3 = 7</code> Â· <code style="color:var(--accent)">x^2 - 4 = (x-2)*(x+2)</code></p>
      <input class="eq-input" id="initialEq" type="text" placeholder="Ej: 2*x + 1 = x^2 - 3" autocomplete="off" spellcheck="false">
      <div class="eq-status hint" id="s1Status">Escribe una igualdad con el signo =</div>
      <div style="margin-top:14px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
        <button class="builder-btn" id="s1Next" disabled>Continuar â†’</button>
        <button class="hint-toggle" onclick="toggleHint('h1')">ğŸ’¡ Sintaxis aceptada</button>
      </div>
      <div class="hint-box" id="h1">
        <strong style="color:var(--txt)">Operadores:</strong> + âˆ’ * / ^ (potencia)<br>
        <strong style="color:var(--txt)">Funciones:</strong> sqrt(x) Â· abs(x) Â· sin(x) Â· cos(x) Â· exp(x) Â· log(x) Â· ln(x)<br>
        <strong style="color:var(--txt)">Constantes:</strong> e Â· pi<br>
        <strong style="color:var(--txt)">Variables:</strong> cualquier letra (x, y, a, b, tâ€¦)<br>
        <strong style="color:var(--txt)">Importante:</strong> <code style="color:var(--accent)">2*x</code> no <code style="color:#f87171">2x</code> Â· debe tener exactamente un signo =
      </div>
    </div>

    <!-- PASO 2 -->
    <div id="builderStep2" style="display:none;">
      <div class="step-label">Paso 2 â€” Aplica transformaciones</div>
      <p style="font-size:13px;margin-bottom:10px;">Modifica la ecuaciÃ³n aplicando propiedades matemÃ¡ticas. La web verificarÃ¡ que la igualdad se mantenga tras cada paso comparando ambos lados numÃ©ricamente.</p>
      <div class="chain-display" id="chainDisplay"></div>
      <div class="steps-container" id="stepsContainer"></div>
      <div class="step-label" style="margin-top:12px;">Atajos de propiedades</div>
      <div class="prop-pill-row" id="propPills">
        <button class="prop-pill" data-action="add_both">Sumar igual a ambos lados</button>
        <button class="prop-pill" data-action="sub_both">Restar igual a ambos lados</button>
        <button class="prop-pill" data-action="mul_both">Multiplicar ambos lados</button>
        <button class="prop-pill" data-action="div_both">Dividir ambos lados</button>
        <button class="prop-pill" data-action="square_both">Elevar al cuadrado ambos lados</button>
        <button class="prop-pill" data-action="sqrt_both">RaÃ­z cuadrada ambos lados</button>
        <button class="prop-pill" data-action="simplify">Simplificar automÃ¡ticamente</button>
      </div>
      <div id="propModal" style="display:none;background:var(--s2);border:1px solid var(--border2);border-radius:10px;padding:14px;margin:8px 0;">
        <div class="step-label" id="propModalLabel">Valor a aplicar</div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <input class="eq-input" id="propValue" type="text" placeholder="Ej: 5" style="max-width:240px;" autocomplete="off">
          <button class="builder-btn" id="propApply">Aplicar</button>
          <button class="builder-btn secondary" onclick="document.getElementById('propModal').style.display='none'">âœ•</button>
        </div>
      </div>
      <div style="margin-top:14px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
        <button class="builder-btn" id="s2Next" disabled>Usar esta ecuaciÃ³n â†’</button>
        <button class="builder-btn secondary" id="s2Back">â† Paso 1</button>
      </div>
      <div class="error-list" id="s2Errors"><ul id="s2ErrorList"></ul></div>
    </div>

    <!-- PASO 3 -->
    <div id="builderStep3" style="display:none;">
      <div class="step-label">Paso 3 â€” Define la incÃ³gnita</div>
      <p style="font-size:13px;margin-bottom:10px;">Elige cuÃ¡l serÃ¡ la variable independiente. La web intentarÃ¡ despejarla y reescribir la expresiÃ³n como <strong style="color:var(--txt)">f(x) = â€¦</strong> igualada a cero.</p>
      <div class="step-label" style="margin-top:8px;">Variables detectadas:</div>
      <div class="var-row" id="varBtns"></div>
      <div class="eq-status hint" id="s3Status">Selecciona la variable independiente</div>
      <hr class="builder-divider">
      <div class="step-label">ExpresiÃ³n manual (opcional)</div>
      <p style="font-size:13px;margin-bottom:8px;">Si el despeje automÃ¡tico falla, escribe tÃº mismo la expresiÃ³n final en tÃ©rminos de la variable elegida (lo que irÃ¡ a la derecha de f(x) =):</p>
      <input class="eq-input" id="manualExpr" type="text" placeholder="Ej: x^2 - 4*x + 3" autocomplete="off" spellcheck="false">
      <div class="eq-status hint" id="s3ManualStatus">Opcional</div>
      <div style="margin-top:14px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
        <button class="builder-btn" id="s3Next" disabled>Generar funciÃ³n â†’</button>
        <button class="builder-btn secondary" id="s3Back">â† Paso 2</button>
      </div>
      <div class="error-list" id="s3Errors"><ul id="s3ErrorList"></ul></div>
    </div>

    <!-- PASO 4 -->
    <div id="builderStep4" style="display:none;">
      <div class="step-label">Paso 4 â€” FunciÃ³n generada</div>
      <div class="result-block">
        <div class="rl">FunciÃ³n resultante</div>
        <div class="result-fn-display" id="resultFnText"></div>
        <div id="resultMath" style="margin-top:6px;color:var(--txt);font-size:1rem;"></div>
        <div class="eq-status ok" id="resultNote" style="margin-top:8px;"></div>
      </div>
      <div class="graph-wrap" style="margin-top:14px;padding:12px 12px 12px;">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
          <div class="graph-title" style="margin:0;">GrÃ¡fica interactiva â€” arrastra Â· rueda para zoom</div>
          <div style="display:flex;gap:6px;">
            <button class="graph-ctrl-btn" id="gcZoomIn"  title="Acercar">+</button>
            <button class="graph-ctrl-btn" id="gcZoomOut" title="Alejar">âˆ’</button>
            <button class="graph-ctrl-btn" id="gcReset"   title="Restablecer vista">âŒ‚</button>
          </div>
        </div>
        <canvas id="cvResult" style="display:block;width:100%;border-radius:8px;touch-action:none;"></canvas>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:14px;">
        <button class="builder-btn secondary" id="s4Reset">âœ¦ Crear otra funciÃ³n</button>
        <button class="builder-btn secondary" id="s4Back">â† Paso 3</button>
      </div>
    </div>

  </div><!-- /builder-card -->

  <footer class="site-footer">
    <p><a href="index.html">Inicio</a> &nbsp;Â·&nbsp; <a href="https://github.com/lasu-aerospace/calculadora-cientifica">GitHub</a></p>
  </footer>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MOTOR DE GRÃFICAS â€” Universal, responsive, interactivo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const C = {
  bg:'#13141a', grid:'#2a2d3a', axis:'#363a4a', txt:'#52566a',
  accent:'#4ade80', blue:'#60a5fa', orange:'#fb923c',
  pink:'#f472b6', purple:'#a78bfa',
};

// â”€â”€ Utilidad: nÃºmero bonito â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fmtNum(n) {
  if (!isFinite(n)) return 'â€”';
  const a = Math.abs(n);
  if (a === 0) return '0';
  if (a >= 1e4 || (a < 0.01 && a > 0)) return n.toExponential(2);
  return parseFloat(n.toFixed(3)).toString();
}

function niceStep(raw) {
  if (!raw || raw <= 0) return 1;
  const exp  = Math.floor(Math.log10(raw));
  const frac = raw / Math.pow(10, exp);
  const nice = frac < 1.5 ? 1 : frac < 3.5 ? 2 : frac < 7.5 ? 5 : 10;
  return nice * Math.pow(10, exp);
}

// â”€â”€ FÃ¡brica de grÃ¡ficas interactivas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  opts: { interactive, tooltip, aspectRatio, tipFn }
//  layers: array de funciones layer(ctx, W, H, toX, toY, view)
//  Devuelve { redraw, destroy, zoomIn, zoomOut, resetView, setView }
function makeChart(canvasId, initView, layers, opts = {}) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return null;
  const wrap = canvas.parentElement;
  const AR   = opts.aspectRatio || 0.52;
  const interactive = opts.interactive !== false;
  const showTip     = !!opts.tipFn && interactive;

  // Always use 1 internally â€” we scale the canvas resolution manually
  // and keep all coordinates in CSS-pixel / logical space.
  const DPR = Math.min(window.devicePixelRatio || 1, 2); // cap at 2Ã— to save memory

  let view = { ...initView };
  let W = 0, H = 0, ctx = null, rafId = null;

  // â”€â”€ Resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function resize() {
    // Measure the actual inner width of the wrap, accounting for padding
    const cs = getComputedStyle(wrap);
    const padH = parseFloat(cs.paddingLeft||0) + parseFloat(cs.paddingRight||0);
    const newW = Math.floor((wrap.getBoundingClientRect().width || wrap.clientWidth) - padH) || 300;
    const newH = Math.max(Math.round(newW * AR), 160);
    if (W === newW && H === newH && ctx) return false;
    W = newW; H = newH;
    canvas.width  = W * DPR;
    canvas.height = H * DPR;
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    ctx = canvas.getContext('2d');
    ctx.scale(DPR, DPR);
    return true;
  }

  // â”€â”€ Coordinate transforms (all in logical/CSS pixels) â”€â”€â”€
  function mkXforms() {
    const toX  = xv => (xv - view.xMin) / (view.xMax - view.xMin) * W;
    const toY  = yv => H - (yv - view.yMin) / (view.yMax - view.yMin) * H;
    const toMX = px =>  view.xMin + (px / W) * (view.xMax - view.xMin);
    const toMY = py =>  view.yMin + ((H - py) / H) * (view.yMax - view.yMin);
    return { toX, toY, toMX, toMY };
  }

  // â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function draw() {
    rafId = null;
    if (!ctx || W === 0) return;
    const { toX, toY } = mkXforms();
    const { xMin, xMax, yMin, yMax } = view;

    ctx.fillStyle = C.bg;
    ctx.fillRect(0, 0, W, H);

    // Grid
    const gs = niceStep((xMax - xMin) / 7);
    ctx.strokeStyle = C.grid; ctx.lineWidth = 0.5;
    for (let x = Math.ceil(xMin/gs)*gs; x <= xMax + gs*0.01; x += gs) {
      const px = toX(x);
      ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, H); ctx.stroke();
    }
    for (let y = Math.ceil(yMin/gs)*gs; y <= yMax + gs*0.01; y += gs) {
      const py = toY(y);
      ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(W, py); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = C.axis; ctx.lineWidth = 1.5;
    if (yMin <= 0 && yMax >= 0) {
      ctx.beginPath(); ctx.moveTo(0, toY(0)); ctx.lineTo(W, toY(0)); ctx.stroke();
    }
    if (xMin <= 0 && xMax >= 0) {
      ctx.beginPath(); ctx.moveTo(toX(0), 0); ctx.lineTo(toX(0), H); ctx.stroke();
    }

    // Labels
    const pxPerUnit = W / (xMax - xMin);
    const labelStep = gs * (pxPerUnit * gs < 40 ? 2 : 1);
    const fontSize  = Math.round(Math.max(8, Math.min(10, W / 50)));
    ctx.fillStyle = C.txt;
    ctx.font = `${fontSize}px JetBrains Mono, monospace`;

    ctx.textAlign = 'center';
    for (let x = Math.ceil(xMin/labelStep)*labelStep; x <= xMax; x += labelStep) {
      if (Math.abs(x) < gs * 0.05) continue;
      const px = toX(x);
      if (px < fontSize || px > W - fontSize) continue;
      const axY = toY(0);
      const ly = axY > H - 14 ? axY - 5 : axY < 12 ? axY + 10 : axY + 11;
      ctx.fillText(fmtNum(x), px, ly);
    }
    ctx.textAlign = 'right';
    for (let y = Math.ceil(yMin/labelStep)*labelStep; y <= yMax; y += labelStep) {
      if (Math.abs(y) < gs * 0.05) continue;
      const py = toY(y);
      if (py < 8 || py > H - 6) continue;
      const axX = toX(0);
      const lx = axX < 24 ? axX + 28 : axX > W - 8 ? W - 4 : axX - 4;
      ctx.fillText(fmtNum(y), lx, py + 3);
    }

    // Layers
    layers.forEach(fn => { try { fn(ctx, W, H, toX, toY, view); } catch(e){} });
  }

  function sched() { if (!rafId) rafId = requestAnimationFrame(draw); }

  // â”€â”€ Zoom â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function zoomAt(px, py, factor) {
    const { toMX, toMY } = mkXforms();
    const cx = toMX(px), cy = toMY(py);
    view.xMin = cx + (view.xMin - cx) * factor;
    view.xMax = cx + (view.xMax - cx) * factor;
    view.yMin = cy + (view.yMin - cy) * factor;
    view.yMax = cy + (view.yMax - cy) * factor;
    sched();
  }

  // â”€â”€ Tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let tipEl = null;
  if (showTip) {
    tipEl = document.createElement('div');
    tipEl.style.cssText = `
      position:absolute;pointer-events:none;display:none;
      background:var(--s2);border:1px solid var(--border2);border-radius:6px;
      font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--txt2);
      padding:4px 9px;white-space:nowrap;z-index:10;`;
    // wrap must be positioned
    if (getComputedStyle(wrap).position === 'static') wrap.style.position = 'relative';
    wrap.appendChild(tipEl);
  }

  function hideTip() { if (tipEl) tipEl.style.display = 'none'; }

  function showCrosshair(mx, my) {
    if (!opts.tipFn) return;
    const { toMX, toMY, toX, toY } = mkXforms();
    const mathX = toMX(mx);
    const tip = opts.tipFn(mathX);
    if (!tip) { hideTip(); return; }

    if (tipEl) {
      tipEl.style.display = '';
      tipEl.textContent = tip.text;
      // Position: prefer right of cursor, flip if near edge
      const tw = tipEl.offsetWidth || 150;
      const th = tipEl.offsetHeight || 24;
      let tx = mx + 14, ty = my - th - 8;
      if (tx + tw > W) tx = mx - tw - 10;
      if (ty < 4) ty = my + 10;
      tipEl.style.left = tx + 'px';
      tipEl.style.top  = ty + 'px';
    }

    // Crosshair overlay (after main draw)
    requestAnimationFrame(() => {
      if (!ctx || tip.y === undefined) return;
      const px = toX(mathX), py = toY(tip.y);
      const ay = Math.min(Math.max(toY(0), 0), H);
      const ax = Math.min(Math.max(toX(0), 0), W);
      ctx.save();
      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = C.txt; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, ay); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(ax, py); ctx.stroke();
      ctx.restore();
      ctx.fillStyle = C.accent;
      ctx.strokeStyle = C.bg; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(px, py, 4.5, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
    });
  }

  // â”€â”€ Pointer position (handles mouse + touch uniformly) â”€â”€
  // Returns CSS pixel coords relative to canvas top-left.
  function getPos(e, touchIndex = 0) {
    const r = canvas.getBoundingClientRect();
    const src = e.touches ? e.touches[touchIndex] :
                e.changedTouches ? e.changedTouches[touchIndex] : e;
    if (!src) return null;
    return {
      x: (src.clientX - r.left),
      y: (src.clientY - r.top),
    };
  }

  // â”€â”€ Interaction state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let dragging = false, dragStart = null, viewSnap = null, pinchDist = null;

  function onDown(e) {
    if (e.touches && e.touches.length > 1) return; // handled by pinch
    e.preventDefault();
    const pos = getPos(e);
    if (!pos) return;
    dragging  = true;
    dragStart = pos;
    viewSnap  = { ...view };
    if (!e.touches) canvas.style.cursor = 'grabbing';
  }

  function onMove(e) {
    if (e.touches && e.touches.length >= 2) { onPinch(e); return; }
    e.preventDefault();
    const pos = getPos(e);
    if (!pos) return;
    const { x: mx, y: my } = pos;

    if (dragging && dragStart && viewSnap) {
      hideTip();
      const dx = (mx - dragStart.x) / W * (viewSnap.xMax - viewSnap.xMin);
      const dy = (my - dragStart.y) / H * (viewSnap.yMax - viewSnap.yMin);
      view.xMin = viewSnap.xMin - dx; view.xMax = viewSnap.xMax - dx;
      view.yMin = viewSnap.yMin + dy; view.yMax = viewSnap.yMax + dy;
      sched();
    } else if (showTip) {
      sched();
      showCrosshair(mx, my);
    }
  }

  function onUp(e) {
    dragging = false;
    if (!e.touches) canvas.style.cursor = 'crosshair';
  }

  function onLeave() {
    dragging = false;
    hideTip();
    canvas.style.cursor = 'crosshair';
  }

  function onTouchEnd(e) {
    if (e.touches.length === 0) {
      dragging = false;
      pinchDist = null;
      hideTip();
    }
  }

  function onWheel(e) {
    e.preventDefault();
    const pos = getPos(e);
    if (!pos) return;
    zoomAt(pos.x, pos.y, e.deltaY > 0 ? 1.13 : 1/1.13);
  }

  function onPinch(e) {
    e.preventDefault();
    if (e.touches.length < 2) return;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 1) return;
    const r  = canvas.getBoundingClientRect();
    const mx = ((e.touches[0].clientX + e.touches[1].clientX)/2) - r.left;
    const my = ((e.touches[0].clientY + e.touches[1].clientY)/2) - r.top;
    if (pinchDist) zoomAt(mx, my, pinchDist / dist);
    pinchDist = dist;
  }

  if (interactive) {
    canvas.style.cursor = 'crosshair';
    canvas.style.touchAction = 'none'; // prevent browser scroll-hijack
    canvas.addEventListener('mousedown',  onDown,    { passive: false });
    canvas.addEventListener('mousemove',  onMove,    { passive: false });
    canvas.addEventListener('mouseup',    onUp);
    canvas.addEventListener('mouseleave', onLeave);
    canvas.addEventListener('wheel',      onWheel,   { passive: false });
    canvas.addEventListener('touchstart', onDown,    { passive: false });
    canvas.addEventListener('touchmove',  onMove,    { passive: false });
    canvas.addEventListener('touchend',   onTouchEnd);
    canvas.addEventListener('touchcancel',onTouchEnd);
  }

  // â”€â”€ ResizeObserver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ro = new ResizeObserver(() => { if (resize()) sched(); });
  ro.observe(wrap);
  resize();
  sched();

  return {
    redraw:    sched,
    setView(v) { view = { ...v }; sched(); },
    resetView(){ view = { ...initView }; sched(); },
    zoomIn()   { zoomAt(W/2, H/2, 1/1.35); },
    zoomOut()  { zoomAt(W/2, H/2,    1.35); },
    destroy() {
      ro.disconnect();
      if (rafId) cancelAnimationFrame(rafId);
      if (!interactive) return;
      canvas.removeEventListener('mousedown',   onDown);
      canvas.removeEventListener('mousemove',   onMove);
      canvas.removeEventListener('mouseup',     onUp);
      canvas.removeEventListener('mouseleave',  onLeave);
      canvas.removeEventListener('wheel',       onWheel);
      canvas.removeEventListener('touchstart',  onDown);
      canvas.removeEventListener('touchmove',   onMove);
      canvas.removeEventListener('touchend',    onTouchEnd);
      canvas.removeEventListener('touchcancel', onTouchEnd);
      if (tipEl && wrap.contains(tipEl)) wrap.removeChild(tipEl);
    },
  };
}

// â”€â”€ Layer helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function layerFn(fn, color, lw) {
  return (ctx, W, H, toX, toY, view) => {
    ctx.strokeStyle = color; ctx.lineWidth = lw || 2.5; ctx.lineJoin = 'round';
    const STEPS = Math.round(W * 1.6);
    const { xMin, xMax, yMin, yMax } = view;
    const yRange = yMax - yMin;
    ctx.beginPath();
    let started = false, prevY = null;
    for (let i = 0; i <= STEPS; i++) {
      const x = xMin + i * (xMax - xMin) / STEPS;
      let y;
      try { y = fn(x); } catch(e) { started = false; prevY = null; continue; }
      if (y === null || !isFinite(y) || isNaN(y)) { started = false; prevY = null; continue; }
      if (prevY !== null && Math.abs(y - prevY) > yRange * 0.55) { started = false; }
      prevY = y;
      const px = toX(x), py = toY(y);
      if (!started) { ctx.moveTo(px, py); started = true; } else ctx.lineTo(px, py);
    }
    ctx.stroke();
  };
}

function layerDot(xv, yv, color, r) {
  return (ctx, W, H, toX, toY) => {
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(toX(xv), toY(yv), r || 5, 0, 2*Math.PI); ctx.fill();
  };
}

function layerLegend(items) {
  return (ctx, W) => {
    const fs = Math.max(9, Math.min(11, W / 55));
    ctx.font = `${fs}px JetBrains Mono, monospace`; ctx.textAlign = 'left';
    items.forEach(({ color, label }, i) => {
      ctx.fillStyle = color; ctx.fillRect(12, 10 + i*18, 12, 3);
      ctx.fillStyle = C.txt; ctx.fillText(label, 28, 17 + i*18);
    });
  };
}

function layerDash(x1, y1, x2, y2, color) {
  return (ctx, W, H, toX, toY) => {
    ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.setLineDash([4, 3]);
    ctx.beginPath(); ctx.moveTo(toX(x1), toY(y1)); ctx.lineTo(toX(x2), toY(y2)); ctx.stroke();
    ctx.setLineDash([]);
  };
}

function layerHLine(y, color) {
  return (ctx, W, H, toX, toY) => {
    ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.moveTo(0, toY(y)); ctx.lineTo(W, toY(y)); ctx.stroke();
    ctx.setLineDash([]);
  };
}

function layerVLine(x, color) {
  return (ctx, W, H, toX, toY) => {
    ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.moveTo(toX(x), 0); ctx.lineTo(toX(x), H); ctx.stroke();
    ctx.setLineDash([]);
  };
}

function layerCircle(cx, cy, r, color) {
  return (ctx, W, H, toX, toY) => {
    const pxR = Math.abs(toX(cx + r) - toX(cx));
    ctx.strokeStyle = color; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(toX(cx), toY(cy), pxR, 0, 2*Math.PI); ctx.stroke();
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ETIQUETAS DE INTERSECCIÃ“N â€” nÃºcleo compartido
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Draw a labeled point: dot + pill background + "(x, y)" text
// Tries to position the label so it stays inside [0,W] Ã— [0,H]
function drawIntersectionLabel(ctx, W, H, px, py, text, dotColor) {
  const DOT_R  = 4.5;
  const PAD    = 4;
  const FS     = Math.max(8.5, Math.min(10.5, W / 60));
  const MARGIN = 6; // min distance from canvas edge

  ctx.font = `${FS}px JetBrains Mono, monospace`;
  const tw = ctx.measureText(text).width;
  const th = FS + 2;
  const bw = tw + PAD * 2;
  const bh = th + PAD * 2;

  // Candidate offsets: prefer top-right, then try others
  const candidates = [
    { dx:  DOT_R + 5, dy: -(bh + DOT_R + 2) }, // top-right
    { dx:  DOT_R + 5, dy:  DOT_R + 2          }, // bottom-right
    { dx: -(bw + DOT_R + 5), dy: -(bh + DOT_R + 2) }, // top-left
    { dx: -(bw + DOT_R + 5), dy:  DOT_R + 2   }, // bottom-left
    { dx:  DOT_R + 5, dy: -bh/2               }, // right-center
    { dx: -(bw + DOT_R + 5), dy: -bh/2        }, // left-center
  ];

  let bx = px + candidates[0].dx;
  let by = py + candidates[0].dy;
  for (const { dx, dy } of candidates) {
    const cx = px + dx, cy = py + dy;
    if (cx >= MARGIN && cx + bw <= W - MARGIN && cy >= MARGIN && cy + bh <= H - MARGIN) {
      bx = cx; by = cy; break;
    }
  }
  // Final clamp
  bx = Math.max(MARGIN, Math.min(W - bw - MARGIN, bx));
  by = Math.max(MARGIN, Math.min(H - bh - MARGIN, by));

  // Pill background
  ctx.fillStyle = 'rgba(13,14,18,0.82)';
  ctx.strokeStyle = dotColor;
  ctx.lineWidth = 1;
  const br = 4;
  ctx.beginPath();
  ctx.roundRect
    ? ctx.roundRect(bx, by, bw, bh, br)
    : (ctx.rect(bx, by, bw, bh));
  ctx.fill(); ctx.stroke();

  // Text
  ctx.fillStyle = '#e4e6f0';
  ctx.textAlign = 'left';
  ctx.fillText(text, bx + PAD, by + PAD + FS - 1);

  // Connector line from dot to pill
  const pillCX = bx + bw / 2, pillCY = by + bh / 2;
  ctx.strokeStyle = dotColor; ctx.lineWidth = 0.7;
  ctx.setLineDash([2, 2]);
  ctx.beginPath();
  ctx.moveTo(px, py);
  // go to nearest pill edge rather than center
  const edgePX = bx + (pillCX < px ? bw : 0);
  const edgePY = by + bh / 2;
  ctx.lineTo(edgePX, edgePY);
  ctx.stroke();
  ctx.setLineDash([]);

  // Dot (drawn last so it's on top)
  ctx.fillStyle = dotColor;
  ctx.strokeStyle = C.bg; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(px, py, DOT_R, 0, 2*Math.PI);
  ctx.fill(); ctx.stroke();
}

// Bisect to refine a root of g(x) = 0 between xa and xb
function bisect(g, xa, xb, iters = 24) {
  let a = xa, b = xb;
  for (let i = 0; i < iters; i++) {
    const m = (a + b) / 2;
    const gm = g(m);
    if (!isFinite(gm)) break;
    (g(a) * gm <= 0) ? (b = m) : (a = m);
  }
  return (a + b) / 2;
}

// Find sign-change crossings of g(x) in [xMin, xMax], deduplicated by minGap
function findCrossings(g, xMin, xMax, steps, minGap = 0.05) {
  const dx = (xMax - xMin) / steps;
  const roots = [];
  let prev = null;
  for (let i = 0; i <= steps; i++) {
    const x = xMin + i * dx;
    let val;
    try { val = g(x); } catch(e) { prev = null; continue; }
    if (val === null || !isFinite(val)) { prev = null; continue; }
    if (prev !== null && prev.v * val < 0) {
      const xr = bisect(g, prev.x, x);
      if (!isFinite(xr)) { prev = { x, v: val }; continue; }
      if (roots.length === 0 || Math.abs(xr - roots[roots.length-1]) > minGap) {
        roots.push(xr);
      }
    }
    prev = { x, v: val };
  }
  return roots;
}

// Master intersection layer:
//   fns      â€” array of {fn, color} (the curves on the chart)
//   hlines   â€” array of {y, color} (horizontal reference lines, e.g. y=constant)
//   vlines   â€” array of {x, color} (vertical reference lines â€” labels the fn(x) there)
//   circles  â€” array of {cx,cy,r,color} (analytic circle intersections)
function layerIntersections(fns = [], { hlines = [], vlines = [], circles = [] } = {}) {
  return (ctx, W, H, toX, toY, view) => {
    const { xMin, xMax, yMin, yMax } = view;
    const STEPS = Math.round(W * 2.5);
    const MIN_GAP = (xMax - xMin) * 0.03;

    // Only label points inside the visible area (with a small margin)
    function visible(x, y) {
      return x >= xMin && x <= xMax && y >= yMin && y <= yMax;
    }

    function label(x, y, dotColor) {
      if (!visible(x, y)) return;
      const lx = fmtNum(x), ly = fmtNum(y);
      const text = `(${lx}, ${ly})`;
      drawIntersectionLabel(ctx, W, H, toX(x), toY(y), text, dotColor);
    }

    // â”€â”€ 1. Each fn vs. x-axis (zeros) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fns.forEach(({ fn, color }) => {
      const roots = findCrossings(x => { const v = fn(x); return v === null ? NaN : v; }, xMin, xMax, STEPS, MIN_GAP);
      roots.forEach(xr => {
        const yr = fn(xr);
        if (yr !== null && Math.abs(yr) < (yMax - yMin) * 0.02) label(xr, 0, color);
      });
    });

    // â”€â”€ 2. Each fn vs. y-axis (x = 0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (xMin <= 0 && xMax >= 0) {
      fns.forEach(({ fn, color }) => {
        const y0 = fn(0);
        if (y0 !== null && isFinite(y0)) label(0, y0, color);
      });
    }

    // â”€â”€ 3. Each fn vs. each horizontal line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    hlines.forEach(({ y: hy, color: hc }) => {
      fns.forEach(({ fn, color: fc }) => {
        const g = x => { const v = fn(x); return v === null ? NaN : v - hy; };
        const roots = findCrossings(g, xMin, xMax, STEPS, MIN_GAP);
        roots.forEach(xr => {
          const yr = fn(xr);
          if (yr !== null && isFinite(yr)) label(xr, yr, fc);
        });
      });
    });

    // â”€â”€ 4. Each fn vs. each vertical line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    vlines.forEach(({ x: vx }) => {
      if (vx < xMin || vx > xMax) return;
      fns.forEach(({ fn, color: fc }) => {
        const yv = fn(vx);
        if (yv !== null && isFinite(yv)) label(vx, yv, fc);
      });
    });

    // â”€â”€ 5. Each fn vs. each other fn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for (let i = 0; i < fns.length; i++) {
      for (let j = i + 1; j < fns.length; j++) {
        const f1 = fns[i].fn, f2 = fns[j].fn;
        const c1 = fns[i].color;
        const g = x => {
          const a = f1(x), b = f2(x);
          if (a === null || b === null || !isFinite(a) || !isFinite(b)) return NaN;
          return a - b;
        };
        const roots = findCrossings(g, xMin, xMax, STEPS, MIN_GAP);
        roots.forEach(xr => {
          const y1 = f1(xr);
          if (y1 !== null && isFinite(y1)) label(xr, y1, c1);
        });
      }
    }

    // â”€â”€ 6. Circle intersections (analytic + fn) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    circles.forEach(({ cx, cy, r, color: cc }) => {
      fns.forEach(({ fn, color: fc }) => {
        // Check both arc halves: y = cy Â± sqrt(rÂ² - (x-cx)Â²)
        [-1, 1].forEach(sign => {
          const circFn = x => {
            const d = r*r - (x-cx)*(x-cx);
            return d < 0 ? NaN : cy + sign * Math.sqrt(d);
          };
          const g = x => {
            const yc = circFn(x), yf = fn(x);
            if (!isFinite(yc) || yf === null || !isFinite(yf)) return NaN;
            return yf - yc;
          };
          const x0 = Math.max(xMin, cx - r), x1 = Math.min(xMax, cx + r);
          if (x0 >= x1) return;
          const roots = findCrossings(g, x0, x1, Math.round(STEPS/2), MIN_GAP);
          roots.forEach(xr => {
            const yf = fn(xr);
            if (yf !== null && isFinite(yf)) label(xr, yf, fc);
          });
        });
      });
    });
  };
}

// Convenience wrapper: zeros + y-intercept labels for a single fn
function layerZeros(fn, color) {
  return layerIntersections([{ fn, color }]);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GRÃFICAS EDUCATIVAS (Canvas 1-3, familias, transformaciones)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Canvas 1 â€” LÃ­nea vertical
{
  const fnPar = x => x*x/4 - 2;
  makeChart('cvVertical', { xMin:-5, xMax:5, yMin:-4, yMax:4 }, [
    layerFn(fnPar, C.accent, 2.5),
    layerCircle(2, 0, 2, C.orange),
    layerVLine(3, C.pink),
    // IntersecciÃ³n parÃ¡bola Ã— lÃ­nea vertical x=3
    layerIntersections([{ fn: fnPar, color: C.accent }], { vlines: [{ x: 3 }] }),
    // Intersecciones cÃ­rculo Ã— lÃ­nea vertical x=3 (analytic, on circle)
    (ctx, W, H, toX, toY) => {
      [[3, Math.sqrt(3)],[3,-Math.sqrt(3)]].forEach(([x,y]) => {
        drawIntersectionLabel(ctx, W, H, toX(x), toY(y), `(3, ${fmtNum(y)})`, C.pink);
      });
    },
    layerLegend([
      { color: C.accent, label: 'FunciÃ³n (parÃ¡bola)' },
      { color: C.orange, label: 'No-funciÃ³n (cÃ­rculo)' },
      { color: C.pink,   label: 'LÃ­nea vertical x=3' },
    ]),
  ], { interactive: true });
}

// Canvas 2 â€” Inyectividad
{
  const fnCub = x => x*x*x/6;
  const fnPar = x => x*x/4;
  makeChart('cvInyectiva', { xMin:-4, xMax:4, yMin:-2, yMax:6 }, [
    layerFn(fnCub, C.accent, 2.5),
    layerFn(fnPar, C.orange, 2.5),
    layerHLine(1.5, C.pink),
    layerIntersections(
      [{ fn: fnCub, color: C.accent }, { fn: fnPar, color: C.orange }],
      { hlines: [{ y: 1.5, color: C.pink }] }
    ),
    layerLegend([
      { color: C.accent, label: 'Inyectiva: 1 intersecciÃ³n' },
      { color: C.orange, label: 'No inyectiva: 2 intersecciones' },
      { color: C.pink,   label: 'LÃ­nea horizontal y=1.5' },
    ]),
  ], { interactive: true });
}

// Canvas 3 â€” Inversa
{
  const fnExp = x => Math.exp(x);
  const fnLn  = x => x > 0 ? Math.log(x) : null;
  const fnId  = x => x; // y=x for intersection reference
  makeChart('cvInversa', { xMin:-3, xMax:5, yMin:-3, yMax:5 }, [
    layerDash(-3,-3,5,5, C.axis),
    layerFn(fnExp, C.accent, 2.5),
    layerFn(fnLn,  C.blue,   2.5),
    // eË£ hits x-axis never (always > 0), but hits y-axis at (0,1)
    // ln(x) hits x-axis at (1,0) and y-axis never (domain x>0)
    // eË£ and ln(x) intersect y=x at x=1 (eË£) â†’ not shown (they don't cross y=x in visible range)
    // eË£ vs ln(x): they cross each other at x=1 ??? No â€” e^1=eâ‰ ln(1)=0. They don't intersect.
    // But both intersect y=x: eË£=x has no real solution; ln(x)=x also no. So: just axis intersections.
    layerIntersections(
      [{ fn: fnExp, color: C.accent }, { fn: fnLn, color: C.blue }]
    ),
    layerLegend([
      { color: C.accent, label: 'f(x) = eË£' },
      { color: C.blue,   label: 'fâ»Â¹(x) = ln x' },
      { color: C.axis,   label: 'y = x' },
    ]),
  ], { interactive: true });
}

// â”€â”€ Familias â€” charts con redibujado dinÃ¡mico â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let chartLineal = null, chartCuad = null, chartPot = null,
    chartExp = null, chartLog = null, chartTrig = null,
    chartTransform = null;

function drawLineal() {
  const m = parseFloat(document.getElementById('slopeM').value);
  const b = parseFloat(document.getElementById('slopeB').value);
  document.getElementById('slopeVal').textContent = m;
  document.getElementById('slopeBVal').textContent = b;
  if (chartLineal && chartLineal.destroy) chartLineal.destroy();
  const fn = x => m*x + b;
  chartLineal = makeChart('cvLineal', { xMin:-6, xMax:6, yMin:-5, yMax:5 }, [
    layerFn(fn, C.accent, 2.5),
    layerIntersections([{ fn, color: C.accent }]),
    layerLegend([{ color: C.accent, label: `f(x) = ${m}x + ${b}` }]),
  ], { interactive: true,
    tipFn: x => { const y = fn(x); return { text: `x=${fmtNum(x)}  f=${fmtNum(y)}`, y }; }
  });
}

function drawCuad() {
  const a = parseFloat(document.getElementById('quadA').value) || 0.01;
  const b = parseFloat(document.getElementById('quadB').value);
  const c = parseFloat(document.getElementById('quadC').value);
  document.getElementById('quadAVal').textContent = a;
  document.getElementById('quadBVal').textContent = b;
  document.getElementById('quadCVal').textContent = c;
  if (chartCuad && chartCuad.destroy) chartCuad.destroy();
  const fn = x => a*x*x + b*x + c;
  const vx = -b/(2*a), vy = fn(vx);
  chartCuad = makeChart('cvCuad', { xMin:-6, xMax:6, yMin:-5, yMax:8 }, [
    layerFn(fn, C.accent, 2.5),
    layerIntersections([{ fn, color: C.accent }]),
    // Vertex label (special named point)
    (ctx, W, H, toX, toY, view) => {
      const { xMin, xMax, yMin, yMax } = view;
      if (vx >= xMin && vx <= xMax && vy >= yMin && vy <= yMax)
        drawIntersectionLabel(ctx, W, H, toX(vx), toY(vy),
          `V(${fmtNum(vx)}, ${fmtNum(vy)})`, C.orange);
    },
    layerLegend([
      { color: C.accent, label: `f(x) = ${a}xÂ² + ${b}x + ${c}` },
      { color: C.orange, label: `VÃ©rtice` },
    ]),
  ], { interactive: true,
    tipFn: x => { const y = fn(x); return { text: `x=${fmtNum(x)}  f=${fmtNum(y)}`, y }; }
  });
}

function drawPot() {
  const n = parseInt(document.getElementById('powN').value);
  document.getElementById('powNVal').textContent = n;
  if (chartPot && chartPot.destroy) chartPot.destroy();
  const fn = x => {
    if (n < 0 && Math.abs(x) < 1e-9) return null;
    return Math.pow(x, n);
  };
  chartPot = makeChart('cvPot', { xMin:-4, xMax:4, yMin:-4, yMax:4 }, [
    layerFn(fn, C.accent, 2.5),
    layerIntersections([{ fn, color: C.accent }]),
    layerLegend([{ color: C.accent, label: `f(x) = x^${n}` }]),
  ], { interactive: true,
    tipFn: x => { const y = fn(x); return y !== null ? { text: `x=${fmtNum(x)}  f=${fmtNum(y)}`, y } : null; }
  });
}

function drawExp() {
  const a = parseFloat(document.getElementById('expA').value);
  document.getElementById('expAVal').textContent = Math.abs(a - Math.E) < 0.05 ? 'e' : a.toFixed(2);
  if (a <= 0 || a === 1) return;
  if (chartExp && chartExp.destroy) chartExp.destroy();
  const fn = x => Math.pow(a, x);
  chartExp = makeChart('cvExp', { xMin:-4, xMax:4, yMin:-0.5, yMax:8 }, [
    layerFn(fn, C.accent, 2.5),
    layerIntersections([{ fn, color: C.accent }]),
    layerLegend([
      { color: C.accent, label: `f(x) = ${Math.abs(a-Math.E)<0.05?'e':a.toFixed(2)}^x` },
    ]),
  ], { interactive: true,
    tipFn: x => { const y = fn(x); return { text: `x=${fmtNum(x)}  f=${fmtNum(y)}`, y }; }
  });
}

function drawLog() {
  const a = parseFloat(document.getElementById('logA').value);
  document.getElementById('logAVal').textContent = Math.abs(a - Math.E) < 0.05 ? 'e' : a.toFixed(2);
  if (a <= 0 || a === 1) return;
  if (chartLog && chartLog.destroy) chartLog.destroy();
  const fn = x => x > 0 ? Math.log(x)/Math.log(a) : null;
  chartLog = makeChart('cvLog', { xMin:-0.5, xMax:8, yMin:-5, yMax:5 }, [
    layerFn(fn, C.accent, 2.5),
    layerVLine(0, C.pink),
    layerIntersections([{ fn, color: C.accent }]),
    layerLegend([
      { color: C.accent, label: `f(x) = log_${Math.abs(a-Math.E)<0.05?'e':a.toFixed(1)}(x)` },
      { color: C.pink,   label: 'AsÃ­ntota x=0' },
    ]),
  ], { interactive: true,
    tipFn: x => { const y = fn(x); return y !== null ? { text: `x=${fmtNum(x)}  f=${fmtNum(y)}`, y } : null; }
  });
}

function drawTrig() {
  const A  = parseFloat(document.getElementById('trigA').value);
  const ww = parseFloat(document.getElementById('trigW').value);
  document.getElementById('trigAVal').textContent = A;
  document.getElementById('trigWVal').textContent = ww;
  if (chartTrig && chartTrig.destroy) chartTrig.destroy();
  const P     = Math.PI / ww;
  const fnSin = x => A * Math.sin(ww * x);
  const fnCos = x => A * Math.cos(ww * x);
  const fnTan = x => {
    const t = Math.tan(ww * x);
    return Math.abs(t) > A * 3 + 3 ? null : t;
  };
  // For trig: only label sin vs x-axis and sin vs cos intersections
  // (tan has infinitely many zeros â€” cap to visible)
  chartTrig = makeChart('cvTrig', { xMin:-4*P, xMax:4*P, yMin:-A*2-1, yMax:A*2+1 }, [
    layerFn(fnSin, C.accent, 2.5),
    layerFn(fnCos, C.blue,   2.5),
    layerFn(fnTan, C.orange, 1.5),
    layerIntersections(
      [{ fn: fnSin, color: C.accent }, { fn: fnCos, color: C.blue }]
      // note: tan excluded from labeling to avoid clutter
    ),
    layerLegend([
      { color: C.accent, label: `${A}Â·sen(${ww}x)` },
      { color: C.blue,   label: `${A}Â·cos(${ww}x)` },
      { color: C.orange, label: `tan(${ww}x)` },
    ]),
  ], { interactive: true,
    tipFn: x => { const y = fnSin(x); return { text: `x=${fmtNum(x)}  sin=${fmtNum(y)}`, y }; }
  });
}

function drawTransform() {
  const h_ = parseFloat(document.getElementById('th').value);
  const k  = parseFloat(document.getElementById('tk').value);
  const c_ = parseFloat(document.getElementById('tc').value);
  document.getElementById('thVal').textContent = h_;
  document.getElementById('tkVal').textContent = k;
  document.getElementById('tcVal').textContent = c_;
  if (chartTransform && chartTransform.destroy) chartTransform.destroy();
  const fn   = x => c_*(x-h_)*(x-h_) + k;
  const base = x => x*x;
  chartTransform = makeChart('cvTransform', { xMin:-5, xMax:5, yMin:-2, yMax:8 }, [
    layerFn(base, C.grid,   1.5),
    layerFn(fn,   C.accent, 2.5),
    layerIntersections(
      [{ fn, color: C.accent }, { fn: base, color: C.blue }]
    ),
    // Vertex label
    (ctx, W, H, toX, toY, view) => {
      const { xMin, xMax, yMin, yMax } = view;
      if (h_ >= xMin && h_ <= xMax && k >= yMin && k <= yMax)
        drawIntersectionLabel(ctx, W, H, toX(h_), toY(k),
          `V(${fmtNum(h_)}, ${fmtNum(k)})`, C.orange);
    },
    layerLegend([
      { color: C.txt,    label: 'xÂ² (base)' },
      { color: C.accent, label: `${c_}(xâˆ’${h_})Â²+${k}` },
      { color: C.orange, label: 'VÃ©rtice' },
    ]),
  ], { interactive: true,
    tipFn: x => { const y = fn(x); return { text: `x=${fmtNum(x)}  f=${fmtNum(y)}`, y }; }
  });
}

// â”€â”€ Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('familyTabs').addEventListener('click', e => {
  const btn = e.target.closest('.tab-btn');
  if (!btn) return;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
  btn.classList.add('active');
  const tab = btn.dataset.tab;
  document.getElementById('tab-'+tab).classList.add('active');
  setTimeout(() => {
    ({ lineal:drawLineal, cuadratica:drawCuad, potencia:drawPot,
       exponencial:drawExp, logaritmo:drawLog, trigono:drawTrig })[tab]?.();
  }, 60);
});

// â”€â”€ Sliders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
['slopeM','slopeB'].forEach(id => document.getElementById(id).addEventListener('input', drawLineal));
['quadA','quadB','quadC'].forEach(id => document.getElementById(id).addEventListener('input', drawCuad));
document.getElementById('powN').addEventListener('input', drawPot);
document.getElementById('expA').addEventListener('input', drawExp);
document.getElementById('logA').addEventListener('input', drawLog);
['trigA','trigW'].forEach(id => document.getElementById(id).addEventListener('input', drawTrig));
['th','tk','tc'].forEach(id => document.getElementById(id).addEventListener('input', drawTransform));

// â”€â”€ Initial draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('load', () => {
  drawLineal();
  drawTransform();
  builderInit();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTRUCTOR DE FUNCIONES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function builderInit() {

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const state = {
    step: 1,
    initialLHS: '',
    initialRHS: '',
    currentLHS: '',
    currentRHS: '',
    steps: [],         // [{lhs,rhs,prop,valid,error}]
    variable: '',
    fnExpr: '',
  };

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const $ = id => document.getElementById(id);

  function toggleHintGlobal(id) {
    const el = $(id);
    if (el) el.classList.toggle('visible');
  }
  window.toggleHint = toggleHintGlobal;

  // Parse LHS = RHS safely
  function parseEq(str) {
    const parts = str.split('=');
    if (parts.length !== 2) return null;
    return { lhs: parts[0].trim(), rhs: parts[1].trim() };
  }

  // Evaluate expression at a scope using mathjs
  function evalExpr(expr, scope) {
    try {
      return math.evaluate(expr, { ...scope });
    } catch(e) {
      return NaN;
    }
  }

  // Check if lhs == rhs is an IDENTITY (holds for all x) â€” used only for Paso 1
  function checkIdentity(lhs, rhs, vars) {
    if (!lhs || !rhs) return { ok: false, msg: 'ExpresiÃ³n vacÃ­a' };
    if (vars.length === 0) {
      // Constant equation â€” just evaluate
      const l = evalExpr(lhs, {}), r = evalExpr(rhs, {});
      if (!isFinite(l) || !isFinite(r)) return { ok: true, msg: 'âœ“ Sintaxis vÃ¡lida' };
      return Math.abs(l - r) < 1e-9
        ? { ok: true,  msg: 'âœ“ Igualdad numÃ©rica verificada' }
        : { ok: false, msg: `Los lados no son iguales (${l.toFixed(4)} â‰  ${r.toFixed(4)})` };
    }
    const trials = 10;
    let valid = 0;
    for (let t = 0; t < trials; t++) {
      const scope = {};
      vars.forEach(v => { scope[v] = (Math.random() * 8 - 4) + 0.07; });
      const l = evalExpr(lhs, scope);
      const r = evalExpr(rhs, scope);
      if (!isFinite(l) || !isFinite(r)) { valid++; continue; } // skip undefined points
      if (Math.abs(l - r) > 1e-6 * (Math.abs(l) + Math.abs(r) + 1)) {
        return { ok: false, msg: `No es una identidad â€” los lados difieren para algunos valores de ${vars.join(',')} (LHSâ‰ˆ${l.toFixed(4)}, RHSâ‰ˆ${r.toFixed(4)})` };
      }
      valid++;
    }
    return { ok: true, msg: 'âœ“ Identidad verificada' };
  }

  // Check that a TRANSFORMATION is valid: (newLHS - newRHS) is proportional/equivalent
  // to (prevLHS - prevRHS), meaning the equation's solution set is preserved.
  // Strategy: verify that (newLHS - newRHS) = 0 whenever (prevLHS - prevRHS) = 0,
  // tested by checking that the difference (newLHS - newRHS) - k*(prevLHS - prevRHS) â‰ˆ 0
  // for the same k across multiple points. More robustly: just verify syntax is valid
  // and that the user's new equation is internally consistent (parseable).
  // The key invariant we CAN check: (newLHS - newRHS) evaluated at random points
  // should have the SAME SIGN PATTERN as (prevLHS - prevRHS) â€” or differ by a
  // positive constant factor (allowed operations: +c, -c, *c, /c, ^2 with care).
  // Simplest correct check: verify newLHS - newRHS â‰¡ prevLHS - prevRHS (same expression up to simplification).
  function checkTransformation(prevLHS, prevRHS, newLHS, newRHS, vars) {
    if (!newLHS || !newRHS) return { ok: false, msg: 'ExpresiÃ³n vacÃ­a' };
    try { math.parse(newLHS); } catch(e) { return { ok: false, msg: `Error en lado izquierdo: ${e.message}` }; }
    try { math.parse(newRHS); } catch(e) { return { ok: false, msg: `Error en lado derecho: ${e.message}` }; }

    if (vars.length === 0) return { ok: true, msg: 'âœ“ TransformaciÃ³n vÃ¡lida' };

    // Compute prev residual and new residual at many points.
    // A valid transformation means: whenever prev_res = 0, new_res = 0 (and vice versa ideally).
    // We verify: new_res / prev_res is approximately constant (or new_res = prev_res + constant, etc.)
    // Actually the most reliable check: verify that (newLHS - newRHS) - (prevLHS - prevRHS) simplifies
    // to something independent of variables, OR that (newLHS-newRHS) = f(prevLHS-prevRHS) for a monotone f.
    // 
    // Practical approach that covers all common cases:
    // Collect ratio = (newLHS-newRHS) / (prevLHS-prevRHS) at non-zero points.
    // If ratio is constant â†’ valid (multiply/divide).
    // If diff = (newLHS-newRHS) - (prevLHS-prevRHS) is constant â†’ valid (add/subtract same to both).
    // If newLHS-newRHS â‰ˆ 0 whenever prevLHS-prevRHS â‰ˆ 0 â†’ valid (same solution set).

    const trials = 20;
    const diffs = [], ratios = [];
    let zeroMatches = 0, zeroTotal = 0;

    for (let t = 0; t < trials; t++) {
      const scope = {};
      vars.forEach(v => { scope[v] = (Math.random() * 10 - 5) + 0.13; });
      const pL = evalExpr(prevLHS, scope), pR = evalExpr(prevRHS, scope);
      const nL = evalExpr(newLHS,  scope), nR = evalExpr(newRHS,  scope);
      if (!isFinite(pL)||!isFinite(pR)||!isFinite(nL)||!isFinite(nR)) continue;
      const prevRes = pL - pR;
      const newRes  = nL - nR;
      diffs.push(newRes - prevRes);
      if (Math.abs(prevRes) > 1e-8) ratios.push(newRes / prevRes);
    }

    if (diffs.length < 3) return { ok: true, msg: 'âœ“ No se pudieron probar suficientes puntos, se acepta' };

    // Check 1: diff is constant (add/subtract same to both sides)
    const diffMean = diffs.reduce((a,b)=>a+b,0)/diffs.length;
    const diffVar  = diffs.reduce((a,b)=>a+(b-diffMean)**2,0)/diffs.length;
    if (diffVar < 1e-6) return { ok: true, msg: 'âœ“ TransformaciÃ³n vÃ¡lida (se sumÃ³/restÃ³ la misma cantidad a ambos lados)' };

    // Check 2: ratio is constant and positive (multiply/divide both sides by same nonzero)
    if (ratios.length >= 3) {
      const ratioMean = ratios.reduce((a,b)=>a+b,0)/ratios.length;
      const ratioVar  = ratios.reduce((a,b)=>a+(b-ratioMean)**2,0)/ratios.length;
      if (ratioVar < 1e-4 && isFinite(ratioMean)) {
        return { ok: true, msg: `âœ“ TransformaciÃ³n vÃ¡lida (ambos lados multiplicados por factor â‰ˆ${ratioMean.toFixed(3)})` };
      }
      // Check 2b: ratio is constant and negative (multiply both sides by negative â€” flips but preserves solutions)
      if (ratioVar < 1e-4 && ratioMean < 0) {
        return { ok: true, msg: `âœ“ TransformaciÃ³n vÃ¡lida (multiplicaciÃ³n por factor negativo)` };
      }
    }

    // Check 3: newRes^2 proportional to prevRes^2 (squaring both sides â€” solutions preserved, may add extraneous)
    const sqRatios = diffs.map((_,i)=>{
      // recompute â€” not easy without re-evaluating, skip deep check
    }).filter(r=>r!==undefined);

    // Check 4: Lenient â€” new expression is algebraically equivalent (simplify diff to zero)
    try {
      const diffExpr = `(${newLHS}) - (${newRHS}) - ((${prevLHS}) - (${prevRHS}))`;
      const simplified = math.simplify(diffExpr).toString();
      // If it simplifies to a number (constant), it's valid
      const val = math.evaluate(simplified);
      if (isFinite(val)) return { ok: true, msg: `âœ“ TransformaciÃ³n vÃ¡lida (diferencia constante = ${val.toFixed(4)})` };
    } catch(e) { /* proceed */ }

    // Check 5: try symbolic ratio
    try {
      const ratioExpr = `((${newLHS}) - (${newRHS})) / ((${prevLHS}) - (${prevRHS}))`;
      const simplified = math.simplify(ratioExpr).toString();
      const val = math.evaluate(simplified);
      if (isFinite(val)) return { ok: true, msg: `âœ“ TransformaciÃ³n vÃ¡lida (factor = ${val.toFixed(4)})` };
    } catch(e) { /* proceed */ }

    // Nothing matched â€” the transformation changes the solution set
    return {
      ok: false,
      msg: `La transformaciÃ³n no preserva la ecuaciÃ³n. El nuevo LHSâˆ’RHS no es proporcional ni diferencia constante del anterior. Revisa que hayas aplicado la misma operaciÃ³n a ambos lados.`
    };
  }

  // Kept for backward compat â€” wraps checkIdentity
  function checkEquality(lhs, rhs, vars) {
    return checkIdentity(lhs, rhs, vars);
  }

  // Extract variable names from expression
  function getVars(expr) {
    try {
      const node = math.parse(expr);
      const vars = new Set();
      node.traverse(n => { if (n.isSymbolNode && !math.hasOwnProperty(n.name) && !['e','pi','i','Infinity'].includes(n.name)) vars.add(n.name); });
      // filter out known functions
      const knownFns = new Set(['sin','cos','tan','sqrt','abs','exp','log','ln','asin','acos','atan']);
      return [...vars].filter(v => !knownFns.has(v));
    } catch(e) { return []; }
  }

  function allVars(lhs, rhs) {
    return [...new Set([...getVars(lhs), ...getVars(rhs)])];
  }

  // Update step bubbles
  function setStep(n) {
    state.step = n;
    for (let i=1; i<=4; i++) {
      const b = $(`bub${i}`);
      if (!b) continue;
      b.classList.remove('active','done');
      if (i < n) b.classList.add('done');
      else if (i === n) b.classList.add('active');
    }
    for (let i=1; i<=3; i++) {
      const l = $(`sl${i}${i+1}`);
      if (l) l.classList.toggle('done', i < n);
    }
    ['builderStep1','builderStep2','builderStep3','builderStep4'].forEach((id,idx) => {
      const el = $(id);
      if (el) el.style.display = (idx+1 === n) ? '' : 'none';
    });
    // scroll into view
    $('builder-card').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  // â”€â”€ STEP 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const s1Input = $('initialEq');
  const s1Status = $('s1Status');
  const s1Next = $('s1Next');

  s1Input.addEventListener('input', () => {
    const val = s1Input.value.trim();
    if (!val) { setStatus(s1Status,'hint','Escribe una igualdad con el signo ='); s1Next.disabled=true; s1Input.className='eq-input'; return; }
    const parsed = parseEq(val);
    if (!parsed) { setStatus(s1Status,'error','Debe tener exactamente un signo ='); s1Next.disabled=true; s1Input.className='eq-input error'; return; }
    // try parsing both sides
    try { math.parse(parsed.lhs); } catch(e) { setStatus(s1Status,'error',`Error en lado izquierdo: ${e.message}`); s1Next.disabled=true; s1Input.className='eq-input error'; return; }
    try { math.parse(parsed.rhs); } catch(e) { setStatus(s1Status,'error',`Error en lado derecho: ${e.message}`); s1Next.disabled=true; s1Input.className='eq-input error'; return; }
    const vars = allVars(parsed.lhs, parsed.rhs);
    const check = checkIdentity(parsed.lhs, parsed.rhs, vars);
    if (!check.ok) {
      // It's a conditional equation (not an identity) â€” that's totally fine, just inform
      setStatus(s1Status,'ok','âœ“ EcuaciÃ³n condicional aceptada (no es identidad â€” se cumple solo para ciertos valores)');
      s1Input.className='eq-input ok'; s1Next.disabled=false;
    } else {
      setStatus(s1Status,'ok', check.msg);
      s1Input.className='eq-input ok'; s1Next.disabled=false;
    }
  });

  s1Next.addEventListener('click', () => {
    const parsed = parseEq(s1Input.value.trim());
    state.initialLHS = parsed.lhs;
    state.initialRHS = parsed.rhs;
    state.currentLHS = parsed.lhs;
    state.currentRHS = parsed.rhs;
    state.steps = [];
    renderStep2();
    setStep(2);
  });

  // â”€â”€ STEP 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderStep2() {
    updateChain();
    renderSteps();
    $('s2Next').disabled = false;
    $('s2Errors').classList.remove('visible');
  }

  function updateChain() {
    const chain = $('chainDisplay');
    const vars = allVars(state.currentLHS, state.currentRHS);

    // The current equation is valid if it's a valid transformation of the initial one
    let check;
    if (state.steps.length === 0) {
      // No steps yet â€” current IS the initial, always valid
      check = { ok: true, msg: 'âœ“ EcuaciÃ³n inicial' };
    } else {
      const prev = state.steps.length >= 2 ? state.steps[state.steps.length - 2] : null;
      const prevLHS = prev ? prev.lhs : state.initialLHS;
      const prevRHS = prev ? prev.rhs : state.initialRHS;
      check = checkTransformation(prevLHS, prevRHS, state.currentLHS, state.currentRHS, vars);
    }

    const cls = check.ok ? 'eq-ok' : 'eq-err';
    chain.innerHTML = `<span class="${cls} eq-current">${esc(state.currentLHS)}</span><span class="eq-link">=</span><span class="${cls} eq-current">${esc(state.currentRHS)}</span>`;
    $('s2Next').disabled = !check.ok;
    if (!check.ok) showS2Error([check.msg]);
    else $('s2Errors').classList.remove('visible');
  }

  function renderSteps() {
    const cont = $('stepsContainer');
    cont.innerHTML = '';
    state.steps.forEach((step, idx) => {
      const row = document.createElement('div');
      row.className = 'step-row';

      const wrapLeft = document.createElement('div');
      wrapLeft.className = 'step-input-wrap';
      wrapLeft.innerHTML = `
        <div class="step-label">Paso ${idx+1} â€” ${esc(step.prop)}</div>
        <input class="eq-input ${step.valid?'ok':'error'}" value="${esc(step.lhs)} = ${esc(step.rhs)}" readonly>
        ${step.error ? `<div class="eq-status error">${esc(step.error)}</div>` : `<div class="eq-status ok">âœ“ Igualdad verificada</div>`}
      `;

      const dot = document.createElement('div');
      dot.className = `step-dot ${step.valid?'ok':'error'}`;

      const del = document.createElement('button');
      del.className = 'step-del-btn';
      del.innerHTML = 'âœ•';
      del.title = 'Eliminar paso';
      del.addEventListener('click', () => {
        // revert to state before this step
        if (idx === 0) {
          state.currentLHS = state.initialLHS;
          state.currentRHS = state.initialRHS;
        } else {
          state.currentLHS = state.steps[idx-1].lhs;
          state.currentRHS = state.steps[idx-1].rhs;
        }
        state.steps.splice(idx);
        renderSteps();
        updateChain();
      });

      row.append(wrapLeft, dot, del);
      cont.appendChild(row);
    });

    // Add manual step row at the bottom
    const addRow = document.createElement('div');
    addRow.style.cssText = 'margin-top:8px;';
    addRow.innerHTML = `
      <div class="step-label">Agregar paso manual</div>
      <div style="display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap;">
        <div style="flex:1;min-width:0;">
          <input class="eq-input" id="newStepLHS" type="text" placeholder="Lado izquierdo nuevo" autocomplete="off" spellcheck="false" style="margin-bottom:6px;">
          <input class="eq-input" id="newStepRHS" type="text" placeholder="Lado derecho nuevo" autocomplete="off" spellcheck="false">
          <div class="eq-status hint" id="newStepStatus">Escribe la ecuaciÃ³n transformada</div>
        </div>
        <div style="flex:0 0 auto;">
          <select class="prop-select" id="newStepProp" style="margin-bottom:6px;">
            <option value="">â€” Propiedad aplicada â€”</option>
            <option value="Suma de igual cantidad a ambos lados">Suma de igual cantidad</option>
            <option value="Resta de igual cantidad a ambos lados">Resta de igual cantidad</option>
            <option value="MultiplicaciÃ³n de igual cantidad a ambos lados">MultiplicaciÃ³n de igual cantidad</option>
            <option value="DivisiÃ³n de igual cantidad a ambos lados">DivisiÃ³n de igual cantidad</option>
            <option value="PotenciaciÃ³n de ambos lados">PotenciaciÃ³n</option>
            <option value="RadicaciÃ³n de ambos lados">RadicaciÃ³n</option>
            <option value="Propiedad distributiva">Propiedad distributiva</option>
            <option value="FactorizaciÃ³n">FactorizaciÃ³n</option>
            <option value="SimplificaciÃ³n">SimplificaciÃ³n</option>
            <option value="Propiedad conmutativa">Propiedad conmutativa</option>
            <option value="Propiedad asociativa">Propiedad asociativa</option>
            <option value="Otro">Otro</option>
          </select>
          <button class="builder-btn" id="addStepBtn" style="width:100%;">+ Agregar</button>
        </div>
      </div>
    `;
    cont.appendChild(addRow);

    // liveâ€‘check new step
    const liveCheck = () => {
      const lhs = $('newStepLHS') && $('newStepLHS').value.trim();
      const rhs = $('newStepRHS') && $('newStepRHS').value.trim();
      const status = $('newStepStatus');
      if (!status) return;
      if (!lhs || !rhs) { setStatus(status,'hint','Escribe la ecuaciÃ³n transformada'); return; }
      try { math.parse(lhs); } catch(e) { setStatus(status,'error',`LHS: ${e.message}`); return; }
      try { math.parse(rhs); } catch(e) { setStatus(status,'error',`RHS: ${e.message}`); return; }
      const vars = allVars(lhs, rhs);
      const prevLHS = state.currentLHS, prevRHS = state.currentRHS;
      const check = checkTransformation(prevLHS, prevRHS, lhs, rhs, vars);
      setStatus(status, check.ok ? 'ok' : 'error', check.ok ? check.msg : check.msg);
      if ($('newStepLHS')) $('newStepLHS').className = `eq-input ${check.ok?'ok':'error'}`;
      if ($('newStepRHS')) $('newStepRHS').className = `eq-input ${check.ok?'ok':'error'}`;
    };
    setTimeout(()=>{
      const l=$('newStepLHS'), r=$('newStepRHS'), b=$('addStepBtn');
      if (l) l.addEventListener('input', liveCheck);
      if (r) r.addEventListener('input', liveCheck);
      if (b) b.addEventListener('click', addManualStep);
    }, 0);
  }

  function addManualStep() {
    const lhs = $('newStepLHS').value.trim();
    const rhs = $('newStepRHS').value.trim();
    const prop = $('newStepProp').value || 'TransformaciÃ³n manual';
    if (!lhs || !rhs) { showS2Error(['Debes completar ambos lados del paso']); return; }
    try { math.parse(lhs); } catch(e) { showS2Error([`Error en LHS: ${e.message}`]); return; }
    try { math.parse(rhs); } catch(e) { showS2Error([`Error en RHS: ${e.message}`]); return; }
    const vars = allVars(lhs, rhs);
    const check = checkTransformation(state.currentLHS, state.currentRHS, lhs, rhs, vars);
    if (!check.ok) {
      showS2Error([check.msg]);
      return;
    }
    state.steps.push({ lhs, rhs, prop, valid: true, error: null });
    state.currentLHS = lhs;
    state.currentRHS = rhs;
    $('s2Errors').classList.remove('visible');
    renderSteps();
    updateChain();
  }

  function showS2Error(msgs) {
    $('s2Errors').classList.add('visible');
    $('s2ErrorList').innerHTML = msgs.map(m=>`<li>${esc(m)}</li>`).join('');
  }

  // Property shortcuts
  let pendingAction = null;
  $('propPills').addEventListener('click', e => {
    const btn = e.target.closest('.prop-pill');
    if (!btn) return;
    const action = btn.dataset.action;
    if (action === 'simplify') {
      applySimplify(); return;
    }
    pendingAction = action;
    const labels = {
      add_both: 'Valor a sumar a ambos lados',
      sub_both: 'Valor a restar a ambos lados',
      mul_both: 'Factor por el que multiplicar ambos lados',
      div_both: 'Divisor',
      square_both: null,
      sqrt_both: null,
    };
    if (action === 'square_both') { applyBothSides('square'); return; }
    if (action === 'sqrt_both')   { applyBothSides('sqrt');   return; }
    $('propModalLabel').textContent = labels[action] || 'Valor';
    $('propValue').value = '';
    $('propModal').style.display = '';
  });

  $('propApply').addEventListener('click', () => {
    const val = $('propValue').value.trim();
    if (!val) return;
    applyBothSides(pendingAction, val);
    $('propModal').style.display = 'none';
  });

  function applyBothSides(action, val) {
    let newLHS, newRHS, propName;
    const lhs = state.currentLHS, rhs = state.currentRHS;
    try {
      switch(action) {
        case 'add_both':
          newLHS = `(${lhs}) + (${val})`; newRHS = `(${rhs}) + (${val})`;
          propName = `Suma ${val} a ambos lados`; break;
        case 'sub_both':
          newLHS = `(${lhs}) - (${val})`; newRHS = `(${rhs}) - (${val})`;
          propName = `Resta ${val} a ambos lados`; break;
        case 'mul_both':
          newLHS = `(${lhs}) * (${val})`; newRHS = `(${rhs}) * (${val})`;
          propName = `Multiplica por ${val}`; break;
        case 'div_both':
          newLHS = `(${lhs}) / (${val})`; newRHS = `(${rhs}) / (${val})`;
          propName = `Divide por ${val}`; break;
        case 'square':
          newLHS = `(${lhs})^2`; newRHS = `(${rhs})^2`;
          propName = 'Eleva al cuadrado ambos lados'; break;
        case 'sqrt':
          newLHS = `sqrt(${lhs})`; newRHS = `sqrt(${rhs})`;
          propName = 'RaÃ­z cuadrada de ambos lados'; break;
        default: return;
      }
    } catch(e) { showS2Error([e.message]); return; }
    // Verify parse
    try { math.parse(newLHS); } catch(e) { showS2Error([`LHS invÃ¡lido: ${e.message}`]); return; }
    try { math.parse(newRHS); } catch(e) { showS2Error([`RHS invÃ¡lido: ${e.message}`]); return; }
    const vars = allVars(newLHS, newRHS);
    const check = checkTransformation(lhs, rhs, newLHS, newRHS, vars);
    state.steps.push({ lhs: newLHS, rhs: newRHS, prop: propName, valid: check.ok, error: check.ok ? null : check.msg });
    state.currentLHS = newLHS;
    state.currentRHS = newRHS;
    renderSteps();
    updateChain();
  }

  function applySimplify() {
    try {
      const simplLHS = math.simplify(state.currentLHS).toString();
      const simplRHS = math.simplify(state.currentRHS).toString();
      const vars = allVars(simplLHS, simplRHS);
      const check = checkTransformation(state.currentLHS, state.currentRHS, simplLHS, simplRHS, vars);
      state.steps.push({ lhs: simplLHS, rhs: simplRHS, prop: 'SimplificaciÃ³n automÃ¡tica', valid: check.ok, error: check.ok ? null : check.msg });
      state.currentLHS = simplLHS;
      state.currentRHS = simplRHS;
      renderSteps();
      updateChain();
    } catch(e) {
      showS2Error([`No se pudo simplificar: ${e.message}`]);
    }
  }

  $('s2Next').addEventListener('click', () => {
    // Check for invalid steps
    const badSteps = state.steps.filter(s => !s.valid);
    if (badSteps.length > 0) {
      showS2Error(['Hay pasos con transformaciones invÃ¡lidas. ElimÃ­nalos antes de continuar.']);
      return;
    }
    renderStep3();
    setStep(3);
  });
  $('s2Back').addEventListener('click', () => setStep(1));

  // â”€â”€ STEP 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderStep3() {
    const vars = allVars(state.currentLHS, state.currentRHS);
    const cont = $('varBtns');
    cont.innerHTML = '';
    state.variable = '';
    $('s3Next').disabled = true;
    $('s3Status').textContent = 'Selecciona la variable independiente';
    $('s3Status').className = 'eq-status hint';
    $('manualExpr').value = '';
    $('s3ManualStatus').textContent = 'Opcional';
    $('s3ManualStatus').className = 'eq-status hint';

    if (vars.length === 0) {
      cont.innerHTML = '<span style="color:var(--txt3);font-size:13px;">No se detectaron variables.</span>';
      return;
    }
    vars.forEach(v => {
      const btn = document.createElement('button');
      btn.className = 'var-btn';
      btn.textContent = v;
      btn.addEventListener('click', () => {
        document.querySelectorAll('.var-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        state.variable = v;
        autoDesp();
      });
      cont.appendChild(btn);
    });
  }

  function autoDesp() {
    const v = state.variable;
    const lhs = state.currentLHS;
    const rhs = state.currentRHS;
    const errors = [];
    // Attempt: move everything to one side: lhs - rhs = 0
    let expr = '';
    try {
      const combined = `(${lhs}) - (${rhs})`;
      const simp = math.simplify(combined).toString();
      expr = simp;
      setStatus($('s3Status'), 'ok', `âœ“ ExpresiÃ³n derivada en tÃ©rminos de ${v}`);
      $('s3Next').disabled = false;
      state.fnExpr = expr;
      // Show preview in manual box as suggestion
      $('manualExpr').placeholder = `Sugerencia automÃ¡tica: ${expr}`;
    } catch(e) {
      setStatus($('s3Status'), 'warn', `Despeje automÃ¡tico fallido. Ingresa la expresiÃ³n manualmente.`);
      $('s3Next').disabled = true;
    }
  }

  $('manualExpr').addEventListener('input', () => {
    const val = $('manualExpr').value.trim();
    if (!val) {
      $('s3ManualStatus').textContent = 'Opcional â€” se usarÃ¡ el despeje automÃ¡tico';
      $('s3ManualStatus').className = 'eq-status hint';
      // re-enable if auto works
      if (state.variable && state.fnExpr) $('s3Next').disabled = false;
      return;
    }
    try {
      math.parse(val);
      setStatus($('s3ManualStatus'), 'ok', 'âœ“ ExpresiÃ³n vÃ¡lida');
      state.fnExpr = val;
      $('s3Next').disabled = !state.variable;
    } catch(e) {
      setStatus($('s3ManualStatus'), 'error', `Error: ${e.message}`);
      $('s3Next').disabled = true;
    }
  });

  $('s3Next').addEventListener('click', () => {
    const manualVal = $('manualExpr').value.trim();
    if (manualVal) state.fnExpr = manualVal;
    if (!state.fnExpr) { showS3Error(['No se pudo determinar la expresiÃ³n de la funciÃ³n. IngrÃ©sala manualmente.']); return; }
    buildResult();
    setStep(4);
  });
  $('s3Back').addEventListener('click', () => setStep(2));

  function showS3Error(msgs) {
    $('s3Errors').classList.add('visible');
    $('s3ErrorList').innerHTML = msgs.map(m=>`<li>${esc(m)}</li>`).join('');
  }

  // â”€â”€ STEP 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function buildResult() {
    const v = state.variable;
    const expr = state.fnExpr;
    $('resultFnText').textContent = `f(${v}) = ${expr}`;
    $('resultNote').textContent = `Dominio: determinado por la expresiÃ³n Â· Variable: ${v}`;

    // Trigger MathJax render if available
    if (window.MathJax) {
      $('resultMath').innerHTML = `\\( f(${v}) = ${exprToLatex(expr)} \\)`;
      MathJax.typesetPromise([$('resultMath')]).catch(()=>{});
    }

    // Draw graph
    setTimeout(() => drawResultGraph(v, expr), 120);
  }

  function exprToLatex(expr) {
    try {
      return math.parse(expr).toTex();
    } catch(e) { return expr; }
  }

  // â”€â”€ Result graph â€” powered by makeChart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let igraph = null;

  function drawResultGraph(v, expr) {
    const compiled = (() => { try { return math.compile(expr); } catch(e) { return null; } })();
    if (!compiled) { $('resultFnText').style.color = '#f87171'; return; }

    const ev = (xv) => {
      try {
        const y = compiled.evaluate({ [v]: xv, e: Math.E, pi: Math.PI });
        return (isFinite(y) && !isNaN(y)) ? y : null;
      } catch(e) { return null; }
    };

    // Smart initial view
    const PROBE = 600, BROAD = 20;
    const pts = Array.from({length: PROBE+1}, (_,i) => -BROAD + i*(2*BROAD/PROBE))
      .map(x => ({ x, y: ev(x) })).filter(p => p.y !== null);
    if (pts.length < 4) { $('resultNote').textContent = 'No se pudo graficar (dominio vacÃ­o)'; return; }

    const yvs = pts.map(p => p.y).sort((a,b) => a-b);
    const q1 = yvs[Math.floor(yvs.length*0.10)], q3 = yvs[Math.floor(yvs.length*0.90)];
    const good = pts.filter(p => p.y >= q1-2*(q3-q1) && p.y <= q3+2*(q3-q1));

    let rxMin = Math.min(...good.map(p=>p.x)), rxMax = Math.max(...good.map(p=>p.x));
    let ryMin = Math.min(...good.map(p=>p.y)), ryMax = Math.max(...good.map(p=>p.y));
    const xSp = rxMax-rxMin||2, ySp = ryMax-ryMin||2;
    if (Math.abs(ryMin)<ySp*3) ryMin=Math.min(ryMin,0);
    if (Math.abs(ryMax)<ySp*3) ryMax=Math.max(ryMax,0);
    if (Math.abs(rxMin)<xSp*3) rxMin=Math.min(rxMin,0);
    if (Math.abs(rxMax)<xSp*3) rxMax=Math.max(rxMax,0);
    const px=((rxMax-rxMin)*0.14)||1.5, py=((ryMax-ryMin)*0.18)||1.5;
    const initView = { xMin:rxMin-px, xMax:rxMax+px, yMin:ryMin-py, yMax:ryMax+py };

    // Wire control buttons
    if (igraph && igraph.destroy) igraph.destroy();
    igraph = makeChart('cvResult', initView, [
      layerFn(ev, C.accent, 2.5),
      layerIntersections([{ fn: ev, color: C.accent }]),
      layerLegend([
        { color: C.accent, label: `f(${v}) = ${expr.length>34?expr.slice(0,34)+'â€¦':expr}` },
      ]),
    ], {
      interactive: true,
      aspectRatio: 0.60,
      tipFn: (x) => { const y = ev(x); return y!==null ? { text: `${v}=${fmtNum(x)}  f=${fmtNum(y)}`, y } : null; },
    });

    $('gcZoomIn').onclick  = () => igraph && igraph.zoomIn();
    $('gcZoomOut').onclick = () => igraph && igraph.zoomOut();
    $('gcReset').onclick   = () => igraph && igraph.resetView();
  }

  $('s4Reset').addEventListener('click', () => {
    s1Input.value = ''; s1Input.className = 'eq-input';
    setStatus($('s1Status'),'hint','Escribe una igualdad con el signo =');
    s1Next.disabled = true;
    state.steps = []; state.variable = ''; state.fnExpr = '';
    setStep(1);
  });
  $('s4Back').addEventListener('click', () => setStep(3));

  // â”€â”€ Utils â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function setStatus(el, type, msg) {
    el.textContent = msg;
    el.className = `eq-status ${type}`;
  }
  function esc(str) {
    return String(str||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }
}

</script>
</body>
</html>